{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 "},"page/1001.html":{"url":"page/1001.html","title":"简介","keywords":"","body":"简介 Android的历史和发展 Android的起源 2003年，以Andy Rubin（Android之父）为首的创业者成立了Android 公司，致力于研发一种新型的数码相机系统。不过，由于受市场前景所限，公司快速转向智能手机平台，试图与诺基亚Symbian及微软的Windows Mobile竞争。然而，资金逐渐成为一个问题，最终谷歌公司于2005年收购了Android公司，Andy Rubin开始率领团队开发基于Linux的移动操作系统，绿色机器人形象和预览版本则在2007年诞生。 Android的发展与前景 如果大家去过位于美国加利福尼亚州山景城的谷歌公司总部，一定会被大楼草坪上的绿色机器人和各种甜点雕塑所吸引，这便是Android系统的吉祥物和各个版本代号。显然，在2005年收购Android，可能是谷歌最正确的投资之一。 时至今日，Android已经是家喻户晓的移动平台，也是谷歌公司最为重要的业务之一。有趣的是，几乎每一个Android版本代号，都是一种美味的甜点，这也让原本冷冰冰的操作系统更具人文气息。 Android平台的更新速度相当快 Android平台之所以发展迅速，与其自身优势是分不开的，其开源性、硬件丰富性以及开发便捷性，注定其未来前景大好，发展迅速。 Android的系统架构 Android系统的底层建立在Linux系统之上，该平台由操作系统、中间件、用户界面和应用软件4层组成，它采用一种被称为软件叠层(Software Stack)的方式进行构建。这种软件叠层结构使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低耦合，当下层的层内或层下发生改变时，上层应用层序无需任何改变。 1.应用程序层 Android系统包含一系列的应用程序（Application），包括电子邮件客户端、SMS程序、日历、联系人等。这些都是手机系统里自带的系统APP，也是本书要讲解的主要内容：编写Android系统上的应用程序。 2.应用程序框架 本书要讲解的内容是开发Android系统的APP，而在实际开发时，APP开发是面向底层的应用程序框架(Application Framework)进行的。这一层提供了大量API供开发者使用，这些API在后面将逐步学习到，这里不再阐述。 应用程序框架除了可作为应用程序开发的基础之外，也是软件复用的重要手段，任何已开发完成的APP都可发布它的功能模块——只要遵守了Framework的约定，那么其他应用程序就可使用这个功能模块。 3.函数库 Android包含一套被不同组件所使用的C/C++库的集合。一般来说，Android应用开发者不能直接调用这套C/C++库集，但可以通过它上面的应用程序框架Framework来调用这些库。下面列出一些核心库。 （1）系统C库：一个从BSD(Berkeley Software Distribution)系统派生出来的标准C系统库(libc)，并且专门为嵌入式Linux设备调整过。 （2）媒体库：基于PacketVideo的OpenCORE，这套媒体库支持播放和录制许多流行的音频和视频格式，甚至可以查看静态图片。 （3）Surface Manager：管理对显示子系统的访问，并可以对多个应用程序的2D和3D图层提供无缝整合。 （4）LibWebCore：一个全新的Web浏览器引擎，该引擎对Android浏览器提供支持，也为WebView提供支持，WebView完全可以嵌入到开发者自己的应用程序中。后面的章节会对WebView进行介绍。 （5）SGL：底层的2D图形引擎。 （6）3D libraries：基于OpenGL ES API实现的3D系统，这套3D库既可以使用硬件3D加速（如果硬件支持），也可以使用高度优化的软件3D加速。 （7）FreeType：位图和向量字体显示。 （8）SQLite：供所有应用程序使用的功能强大的轻量级关系型数据库。 4.Android运行时 Android运行时(Android Runtime)由两部分组成：Android核心库集和虚拟机ART。其中核心库集提供了Java语言的核心库所能使用的绝大部分功能，而虚拟机ART则负责运行所有的应用程序。 Android5.0以前的Android运行时由Dalvik虚拟机和Android核心库集组成，但由于Dalvik虚拟机采用了一种被称为JIT(Just-in-time)的解释器进行动态编译并执行，因此导致Android运行时比较慢；而ART模式则是在用户安装APP时进行预编译(Ahead-of-time，简称AoT)，将原本在程序运行时进行的编译动作提前到应用安装时，这样使得程序在运行时可以减少动态编译的开销，从而提升Android App的运行效率。 但是，由于ART需要在安装App时进行AOT处理，因此ART需要占用更多的存储空间，应用安装和系统启动时间会延长不少。 除此之外，ART还支持ARM、x86和MIPS架构，并且完全兼容64位系统，因此Android5.0必然能够带来更好的用户体验。 5.Linux内核 Android系统建立在Linux2.6之上，Linux内核(Linux Kernel)提供了安全性、内存管理、进程管理、网络协议栈和驱动模型等核心系统服务。除此之外，它也是系统硬件和软件叠层之间的抽象层。 "},"page/1004.html":{"url":"page/1004.html","title":"配置","keywords":"","body":"配置 常见错误 1.无法更新gradle 问题描述 无法更新gradle 问题解决 下载离线版使用 具体步骤 下载离线版gradle 在配置里面设置离线gradle目录并设置离线模式 在gradle/wrapper/gradle-wrapper.properties中指定distributionUrl的值，即末尾版本号 即使使用离线版本第一次运行可能需要联网更新 "},"page/1002.html":{"url":"page/1002.html","title":"应用结构","keywords":"","body":"应用结构 目录分析 根目录 .gradle和.idea 这两个目录无须关心，这是Android Studio自动生成的文件，开发者不要去手动更改这些文件。 app 项目中的代码和资源等内容几乎都是放在这个目录下，在实际编写代码时也都是在这个目录下进行，随后将会单独对这个目录进行详细讲解。 build 此目录也不必去关心，里面主要放置一些编译时生成的文件，开发者也不要手动去更改该目录下的文件。 gradle 这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启用gradle wrapper的方式，若需要打开，可以按照Android Studio导航栏→File→Settings命令打开。Gradle版本的版本号在gradle/wrapper/gradle-wrapper.properties中指定distributionUrl的值，如果网络无法同步可以使用gradle离线模式，并在设置中指定gradle离线版本的目录Gradle user home。 .gitignore 此文件是用来将指定的目录或文件排除在版本控制之外，关于版本控制会在之后的目录中介绍。 build.gradle 这是项目全局的gradle构建脚本，一般此文件中的内容是不需要修改的。稍后详细分析gradle脚本中的内容。 gradle.properties 这个文件是全局的gradle配置文件，在这里配置的属性将会影响到全局的项目中所有的gradle编译脚本。 gradlew和gradlew.bat 这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。 项目.iml iml文件是所有IntelliJ IDEA项目中都会自动生成的一个文件(Android Studio是基于IntelliJ IDEA开发的)，开发者也不用修改这个文件中的任何内容。 local.properties 这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，并不需要修改。除非用户计算机上SDK位置发生变化，那么将这个文件中的路径改成新的路径即可。 settings.gradle 这个文件用于指定项目中所有引入的模块。由于HelloWorld项目中只有一个app模块，因此该文件中也引入了app这一个模块。通常情况下模块的引入都是自动完成的，需要手动修改这个文件的场景较少，但是要知道这个文件的作用，避免以后开发中遇到此种情况。 至此，整个项目的外层目录已经介绍完毕。除了app目录之外，绝大多数的文件和目录都是自动生成的，开发者并不需要修改。而app目录才是之后开发的重点目录 app目录 下面对app目录进行详细分析。 build 这个目录和外层的build目录类似，都是包含一些编译时自动生成的文件，不过它里面的内容更复杂一些，这里不需要关心它。 libs 如果项目中使用了第三方Jar包，就需要把第三方Jar包放在libs目录下，放在这个目录下的Jar都会被自动添加到构建路径中去。 src/androidTest 此处用来编写Android Test测试用例，可以对项目进行一些自动化测试。 src/main/java 毫无疑问，java目录是用来放置java代码的地方，展开该目录，可以看到之前创建的HelloWorldActivity文件。 src/main/res 这个目录下的内容有点多。简单点说，开发中使用到的所有图片、布局、字符串等都要放在这个目录下。从上图可以看出，此目录下还有很多目录，图片放在mipmap目录下，布局放在layout目录下，字符串放在values目录下，所以整个res目录虽然子目录很多，但是各有分工，不会被弄的乱七八糟。 src/test 此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。 .gitignore 与外层的.gitignore文件作用相似，是将app模块中的指定文件或目录排除在版本控制之外。 app.iml IntelliJ IDEA项目自动生成的文件，开发者不需要修改此文件内容。 proguard-rules.pro 这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。 build.gradle 不同于Eclipse，Android Studio是采用Gradle来构建项目的。它使用了一种基于Groovy的领域特定语言（Domain Specific Language DSL）来声明项目设置，摒弃了传统基于XML（如Ant和Maven）的各种繁琐配置。 展开的app目录图中，可以看到两个build.gradle文件，一个是Project下的外层文件，一个在app目录下。这两个文件对构建Android项目起到了至关重要的作用，下面来对这两个文件进行详细分析。 文件分析 build.gradle 先看最外层目录下的build.gradle文件，代码如下： // Top-level build file where you can add configuration options common to all sub-projects/modules. buildscript { repositories { google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.6.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { google() jcenter() } } task clean(type: Delete) { delete rootProject.buildDir } 这些代码都是自动生成的，现在来看最关键的部分。 首先，两处repositories的闭包中都声明了jcenter()配置，它是一个代码托管仓库，很多Android的开源项目都会选择将代码托管到jcenter，声明了这行配置之后，就可以在项目中轻松引用任何jcenter中的开源项目了。 接下来，dependencies闭包中使用classpath声明了一个Gradle插件。为什么要声明这个插件呢？因为Gradle并不是专门为构建Android项目而开发，Java、C++等许多项目都可以用Gradle来构建。因此如果想通过Gradle来构建Android项目，就需要使用这个插件。最后面的几个数字是Gradle的插件版本的版本号，非Gradle版本的版本号，Gradle版本的版本号在gradle/wrapper/gradle-wrapper.properties中指定distributionUrl的值，如果网络无法同步可以使用gradle离线模式，并在设置中指定gradle离线版本的目录Gradle user home。 通常情况下，Project目录下的build.gradle文件只有在添加全局的项目构建配置时才会修改。 接下来看app目录下的build.gradle文件，先看HelloWorld项目中该文件的代码。 apply plugin: 'com.android.application' android { compileSdkVersion 29 buildToolsVersion \"29.0.3\" defaultConfig { applicationId \"com.example.myapplication\" minSdkVersion 24 targetSdkVersion 29 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } } dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'androidx.appcompat:appcompat:1.1.0' implementation 'androidx.constraintlayout:constraintlayout:1.1.3' testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test.ext:junit:1.1.1' androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0' } 这个文件稍显复杂，需要仔细分析。首先第一行用到了一个插件，这里的插件一般有两种值可供选择，一个是com.android.application，表示这是一个应用程序模块。一个是com.android.library表示这是一个库模块。应用程序模块和库模块的最大区别在于，一个是可以直接运行的，一个只能作为代码库依附于别的应用模块来运行。 接下来是一个大的android闭包，在这个闭包中可以配置项目构建的各种属性。其中，compileSdkVersion指定项目的编译版本，这里指定成29表示使用Android10.0的SDK编译。buildToolsVersion指定项目构建工具的版本，目前最新的版本是29.0.3。 android闭包中又嵌套了一个defaultConfig闭包，下面来分析这个闭包。ApplicationId用于指定项目的包名，需要修改时直接在这里修改即可。minSdkVersion指定了项目最低兼容的Android系统版本，这里指定24表示最低兼容到Android7.0系统。targetSdkVersion指定的值表示在该目标版本上已经做了充分的测试，系统将为该应用程序启用该版本的最新特性和功能。例如Android10.0引用了运行时权限这个功能，如果将targetSdkVersion指定为29或者以上的版本，那么系统将会为程序启用运行时权限这个功能。剩下的两个属性比较简单，但同时也很重要，versionCode是指项目的版本号，versionName用于指定项目的版本名。这两个属性在生成apk文件时非常重要，以后用到的时候会讲解。 最后是dependencies闭包。这个闭包的功能非常强大，它可以指定当前项目所有的依赖关系。通常Android Studio有三种依赖方式：本地依赖，库依赖和远程依赖。本地依赖可以对本地的Jar包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖则可以对jcenter上的开源项目添加依赖。观察一下dependencies闭包中的配置，第一行的compile fileTree就是一个本地依赖声明，它表示将libs下的所有.jar后缀的文件都添加到项目的构建路径当中。而compile则是远程依赖声明，第二行和第三行分别声明了一个插件，其中com.android.support是域名部分，用于与其他公司的库作区分。Gradle在构建项目的时候会首先检查本地有没有这个库的缓存，如果没有就会自动联网下载，然后在添加到项目的构建路径当中。剩下的testCompile用于声明测试用例库，暂时用不到，先忽略掉。 AndroidManifest.xml app/src/main/res/AndroidManifest.xml这是整个Android项目的配置文件，项目中使用到的四大组件都需要在这目录下进行注册，另外还可以在这个文件中给项目应用添加权限声明。这个文件会经常用到. 接下来详细讲解项目是如何运行起来的。首先打开项目中app/src/main/res/AndroidManifest.xml的AndroidManifest.xml文件，打开之后可以看到如下代码： 这段代码表示在AndroidManifest.xml文件中对MainActivity进行注册，没有注册的Activity是不能使用的。其中intent-filter中的两行代码非常重要，它们表示MainActivity是这个项目的主Activity，启动这个HelloWorld项目时首先启动MainActivity。Activity是Android四大组件之一。 Activity.java 打开app/src/main/java/包名/MainActivity.java的代码，代码很简单，具体如下： package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } } 首先注意到，MainActivity继承自AppCompatActivity，这是一种向下兼容的Activity，可以将Activity在各个版本增加的特性和功能最低兼容到系统Android2.1。读者必须知道，开发中所有自定义的Activity都必须继承自Activity或者Activity的子类才能拥有Activity的特性，此代码中AppCompatActivity是Activity的子类。往下看可以看到有一个onCreate方法，这个方法是Activity创建时必须执行的方法，而在此方法中并没有看到Hello World字样，那么在模拟器中看到的Hello World来自哪里呢？ 其实Android程序的设计讲究逻辑层与视图层分离，在Activity中一般不直接编写界面，而是在布局文件layout中编写，那在Activity中怎么与layout相联系呢？通过setContentView()方法。在上面代码中可以看到，setContentView引入了一个叫做activity_main的layout文件，那么可以猜测，Hello World字样一定来自这个布局文件。按住ctrl+鼠标左键可以直接打开该布局文件，这里顺便提一下，Android Studio有许多快捷键供开发者使用，在后续的开发练习中可以多多练习使用快捷键，这样可以大大提升开发效率。 activity_main.xml 打开activity_main（app/src/main/layout/activity_main.xml）布局文件之后看到以下代码。 在控件TextView里面看到有Hello World!，这就是显示在模拟器界面的Hello World！ "},"page/1005.html":{"url":"page/1005.html","title":"界面","keywords":"","body":"界面 视图组件和容器组件 Android应用的绝大多数UI组件都是放在Android.widget包及其子包、Android.view包及其子包中。 值得注意的是，Android中所有的组件都是继承了View类，View组件代表一个空白的矩形区域。 View类还有一个重要的子类ViewGroup，但ViewGoup类经常作为其他组件的容器使用。 Android的所有UI组件都建立在View、ViewGroup基础之上，它们的组织结构如图所示。 在前面提到，Android讲究逻辑层和视图层分离，开发中一般不在Activity中直接编写界面，而是在布局文件中编写。 Android中所有组件都提供了两种方式来控制组件的运行： 在XML布局文件(即前面说的layout文件)中通过XML属性进行控制。 在Java代码(一般是指Activity)中通过调用方法进行控制。 不管使用哪种方式，其本质和显示出来的效果是一样的。 View类和ViewGroup类 对于View类而言，由于它是所有UI组件的基类，所以它包含的XML属性和方法是所有UI组件都可以使用的。 而ViewGroup类虽然继承了View类，但由于它是抽象类，因此实际使用中通常只是用ViewGroup的子类作为容器。下面来详细讲解两种控制UI组件的方式。 使用XML布局文件控制UI界面 Android推荐使用这种方式来控制视图，因为这样不仅简单直接，而且将视图控制逻辑从Java代码中分离出来，单独在XML文件中控制，更好地体现了MVC原则。 在前面介绍项目的结构目录时，布局文件是放在app\\src\\main\\res\\layout文件夹下面，然后通过Java代码中setContentView()方法在Activity中显示该视图的。 在实际开发中，当遇到有很多UI组件时(实际上这种情况很常见)，各个组件会通过android:id属性给每个组件设置一个唯一的标识。当需要在代码中访问指定的组件时(例如设置单击事件)，就可以通过id值，利用方法findViewById(R.id.id值)来访问。 在设置UI组件时有两个属性值最常用：android:layout_height、android:layout_width，这两个属性支持两种属性值： （1）match_parent：指定子组件的高度和宽度与父组件的高度和宽度相同(实际还有填充的空白距离)。 （2）wrap_content：指定组件的大小恰好能包裹它的内容。 Android机制决定了UI组件的大小不仅受它实际宽度和高度的控制，还受它所在布局的高度和宽度控制，所以在设置组件的宽高时还要考虑布局的宽高。 其实在XML文件中编写界面还有很多的属性，比如gravity、LinearLayout中的orientation、RelativeLayout中的centerInParent属性等等，这些属性在之后的内容中都会讲到。 在代码中控制UI界面 虽然Android中推荐使用XML方式来控制UI界面，但是有时碰到一些特殊情况，例如只需要一个组件时，在代码中采用new的方式比较合适。 下面来看一个完全由代码控制的UI界面的简单应用，具体示例代码如下： package com.example.myapplication; import androidx.appcompat.app.AppCompatActivity; import android.annotation.SuppressLint; import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.Gravity; import android.view.View; import android.view.ViewGroup; import android.widget.Button; import android.widget.LinearLayout; import android.widget.TextView; import static java.lang.String.*; public class MainActivity extends AppCompatActivity { @SuppressLint(\"SetTextI18n\") @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //创建一个线性布局管理器 LinearLayout linearLayout=new LinearLayout(this); //显示创建的线性布局 setContentView(linearLayout); //设置线性布局的方向 linearLayout.setOrientation(LinearLayout.VERTICAL); linearLayout.setGravity(Gravity.CENTER); //创建一个TextView final TextView textView=new TextView(this); textView.setGravity(Gravity.CENTER); //创建一个按钮 Button button=new Button(this); button.setText(\"BUTTON1\"); button.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)); //向布局中添加创建的TextView linearLayout.addView(textView); linearLayout.addView(button); //为按钮绑定一个事件监听器 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { textView.setText(\"Hello world !\"); } }); } } 上面代码的中使用的三个组件LinearLayout、textView、button都是使用关键字new创建的， setContentView()方法加载new 出来的LinearLayout作为布局“容器”， 再通过LinearLayout类的addView()方法把TextView和Button添加进“容器”，这样就组成如图所示界面。 可以看出每new一个组件都会传入一个this参数，这是由于创建UI组件时需要传入一个Context类型的参数，Context代表访问Android应用环境的全局信息的API。让UI组件持有一个Context参数，可以让这些UI组件通过该参数来获取Android应用环境的全局信息。 Context本身是一个抽象类，Android应用中的Activity和Service都继承了Context，因此Activity和Service都可直接作为Context使用。 从上述代码可以看出，完全在代码中控制UI界面不仅需要调用方法来设置UI组件的行为，而且还不利于高层的耦合，因此代码也显得十分臃肿。 而利用XML方式控制UI界面时，开发者只需要在XML布局文件中使用标签即可创建UI组件，而且只要使用属性值就可以控制UI组件的行为。 两者相比较，XML的优势一目了然。因此，Android不推荐使用代码控制UI界面。 自定义UI组件 View组件在布局中是一个矩形的空白区域，没有任何内容。而UI组件之所以有内容，是因为继承了View组件之后在其提供的空白区域上重新绘制外观。这就是Android 的UI组件实现原理。 利用UI组件实现原理，完全可以开发出一些特殊的UI组件，这些自定义UI组件创建时需要定义一个继承View类的子类，然后重写View类的一个或多个方法。通常需要被重写的方法如表所示。 自定义组件完成之后，需要在Java代码中把该组件添加到容器中才可以看到想要的效果，代码如下 BallViewActivity.java package com.example.ballview; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.LinearLayout; import com.example.ballview.view.BallView; public class BallViewActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_ball_view); LinearLayout rootView =findViewById(R.id.root_view); BallView ballView=new BallView(this); ballView.setMinimumWidth(300); ballView.setMinimumHeight(300); rootView.addView(ballView); } } BallView.java package com.example.ballview.view; import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.util.AttributeSet; import android.view.MotionEvent; import android.view.View; public class BallView extends View { public float currentX=60; public float currentY=60; //定义并创建画笔 Paint paint=new Paint(); public BallView(Context context) { super(context); } public BallView(Context context, AttributeSet attrs) { super(context, attrs); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); //设置画笔的颜色 paint.setColor(Color.RED); //画一个圆 canvas.drawCircle(currentX,currentY,20,paint); } @Override public boolean onTouchEvent(MotionEvent event) { //修改 currentX，currentY的值 currentX=event.getX(); currentY=event.getY(); //通知当前组件重新绘制自己 invalidate(); //表明该处理方法已经处理了该事件 return true; } } activity_ball_view.xml activity_main.xml AndroidManifest.xml 用XML布局文件的方式使用更简单，只需要在XML布局文件中直接引用即可，具体代码如下： activity_ball_view.xml 因为已经在XML布局文件中添加了自定义组件，所以BallViewActivity中的代码可以简化成如下： BallViewActivity.java package com.example.ballview; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.LinearLayout; import com.example.ballview.view.BallView; public class BallViewActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_ball_view); } } 显然，这种方式比在代码中控制界面要更方便。 布局管理器 什么是布局 布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面。当然，布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套，就能够实现一些比较复杂的界面。布局和控件的关系如图所示。 为了更好地管理界面中的组件，Android提供了布局管理器，通过布局管理器，Android应用的图形用户界面具备了良好的平台无关性。这就让各个控件可以有条不紊地摆放在界面上，从而极大地提升用户体验。 本节将为大家介绍LinearLayout（线性布局）、FrameLayout（帧布局）、RelativeLayout（相对布局）、AbsoluteLayout（绝对布局）、TableLayout（表格布局）、GridLayout（网格布局）六大基本布局以及它们常用的属性，并且结合不同布局的各自特点给出自身特有的属性（重复的属性不会列出）。这六大基本布局与View类的关系如图所示。 线性布局 线性布局（ LinearLayout ）是一种常用的布局，这个布局会将它所包含的控件在线性方向上依次排列，通过android:orientation属性设置控件排列方向，水平方向为horizontal，垂直方向为vertical。线性布局不会自动换行，当组件按顺序排列到屏幕边缘时，之后的组件将不会显示。 现在介绍LinearLayout中常用的属性，如表所示。 可以看到，gravity与layout_gravity的区别在于，gravity是指本身元素显示在什么位置，layout_gravity是指显示在父元素的什么位置。例如Button组件，gravity属性表示Button上的字在Button上的位置，layout_gravity则表示Button在父界面上的位置。 同时大家还要注意layout_weight这个属性，它表示子元素在布局中的权重。看一个示例代码： 从以上内容即可看出，第7行，当LinearLayout的orientation属性为水平方向的horizontal时，设置控件的width为0，然后第9行设置layout_weight的比重值即可，同理vertical时设置height为0。 表格布局 表格布局（TableLayout）继承于LinearLayout，所以它依然是线性布局管理器，并且LinearLayout的所有属性都适用于TableLayout。TableLayout采用行、列的形式来管理UI组件，但并不需要声明行数和列数，而是通过添加TableRow、其他组件来控制表格的行数和列数。 向TableLayout中添加TableRow就添加一个表格行，而TableLayout也是一个容器，所以也可以向TableLayout中添加组件，每添加一个组件该表格行就增加一列。如果直接向TableLayout中添加一个组件，那么这个组件就直接占用一行。 下表为设置TableLayout单元格的属性。 帧布局 帧布局（ FrameLayout ）相比于前面两种布局就简单多了，它的应用场景相较于其他布局少一些，但在比较复杂的自定义布局中，帧布局是很受欢迎的。因为这种布局没有任何的定位方式，所有的控件都会默认摆放在布局的左上角。 FrameLayout的两个常用属性： android:foreground[setForeground(Drawable)]：定义帧布局容器的绘图前景图像。 android:foregroundGravity[setForegroundGravity(int)]：定义绘图前景图像重力属性。 相对布局 相对布局（ RelativeLayout ） 也是一种非常常用的布局，与 LinearLayout 的排列规则不同的是， RelativeLayout 显得更加随意一些，它总是通过相对定位的方式让控件出现在布局的任何位置，例如相对容器内兄弟组件、父容器的位置决定了它自身的位置。也正因为如此， RelativeLayout 中的属性非常多，不过这些属性都是有规律可循的。 RelativeLayout支持的一些重要属性如表所示。 网格布局 网格布局（ GridLayout ）是Android4.0之后新增的布局管理器，因此正常情况下需要在 Android 4.0 之后的版本中才能使用，如果希望在更早的版本中使用，则需要导入相应的支撑库（v7包下的gridlayout包）。 GridLayout和前面所讲的 TableLayout(表格布局)有点类似，不过它有很多前者没有的特性，因此也更加好用： 可以自己设置布局中组件的排列方式； 可以自定义网格布局有多少行或列； 可以直接设置组件位于某行某列； 可以设置组件横跨几行或者几列。 下表为GridLayout常用属性。 绝对布局 绝对布局（ Absolute Layout ）是由开发人员通过X、Y坐标来控制组件的位置的。绝大多数情况下是不会采用绝对布局编写布局，因为运行Android应用的手机千差万别，屏幕大小、分辨率、屏幕密度等都可能存在较大的差异，使用绝对布局很难做机型适配，因此简单了解这种布局方式即可。 使用绝对布局时，每个子组件都可以指定如下两个XML属性： Layout_x：指定该子组件的X坐标 Layout_y：指定该子组件的Y坐标 当使用绝对布局时，要多次调整各个组件的位置才能达到预期的效果，调整时使用到的单位有以下几种： px（像素）：每个px对应屏幕上的一点 dip或dp（device independent pixels 设备独立像素）：是一种基于屏幕密度的抽象单位。当在每英寸160px的屏幕上时，1dp=1px。但随着屏幕密度的改变，它们之间的换算会发生改变。 sp（scaled pixels 比例像素）：主要用于处理Android中的字体大小。 Android中最常用的两种单位是dp和sp，其中dp一般为间距单位，sp一般设置字体大小单位。 几组重要的UI组件 前面介绍了Android界面编程的一些基础知识，接下来介绍的是Android的几组重要的UI组件。 TextView及其子类 TextView直接继承了View，并且它还是EditText和Button两个UI组件的父类，TextView类图如图所示。TextView的作用就是在界面上显示文本，只是Android关闭了它的文字编辑功能（EditText有编辑功能）。 在上图中可以看到，TextView派生了5个类，除了常用的EditText和Button类之外，还有CheckedTextView，CheckedTextView增加了checked状态，开发者可以通过setChecked(boolean)和isChecked()方法来改变和访问checked状态。 TextView和EditText有很多相似的地方，它们之间最大的区别就是TextView不允许用户编辑文本内容，而EditText则可以。 TextView提供了大量XML属性，这些属性不仅适用于TextView本身，也同样适用于它的子类（EditText、Button等）。 下表列出了TextView的几个常用属性。 当然TextView的属性并不止这些，还有很多属性并没有写出来，在实际开发中，可以通过API文档来查找需要的属性。 下面具体介绍TextView 的几个子类。 1.EditText的功能和用法 EditText组件最重要的属性是inputType，该属性能接收的属性值非常丰富，而且随着Android版本的升级，该属性能接收的类型还会增加。 EditText 还派生了如下两个子类： AutoCompleteTextView：带有自动完成功能的EditText。 ExtractEditText：它并不是UI组件，而是EditText组件的底层服务类，负责提供全屏输入法的支持。 2. Button的功能和用法 Button主要是在界面上生成一个可供用户单击的按钮，当用户单击之后触发其onClick事件。Button使用起来比较简单，通过android:background属性可以改变按钮的背景颜色或背景图片，如果想要这两项内容随着用户动作动态改变，就需要用到自定义的Drawable对象来实现。 关于TextView的其他子类限于篇幅就不做介绍了，有兴趣的同学可以自己尝试编写代码练习。 ImageView及其子类 初次看到ImageView很容易让大家觉得这是一个显示图片的View，这种说法没错，但是不全面，因为它能显示Drawable中的所有对象。如图所示，ImageView派生了ImageButton、QuickContactBadge等组件。 下面看ImageView所支持的常用XML属性，如表所示。 由于android:scaleType属性经常使用到，下面详细介绍它支持的属性值，如表所示。 在上图中可以看到ImageView派生了两个子类： ImageButton：图片按钮 QuickContactBadge：显示关联到特定联系人的图片 Button与ImageButton的区别在于，Button按钮显示文字而ImageButton显示图片（因为ImageButton本质还是ImageView）。 ImageButton派生了一个ZoomButton类，它代表两个按钮“放大”“缩小”，Android默认为ZoomButton提供了\"btn_minus\"、\"btn_plus\"两个属性值，只要设置它们到ZoomButton的android:src属性中就可实现放大、缩小功能。 QuickContactBadge的本质也是图片按钮，也可以通过android:src属性设置图片。但是它可以关联到手机中指定的联系人，当用户单击该图片时，系统会自动打开相应联系人的联系方式界面。 AdapterView及其子类 AdapterView是一个抽象基类，其派生的子类在用法上十分相似，只是显示的界面有所不同，来看它和子类的关系图，如图所示。 可以看出，AdapterView继承自ViewGroup，它本质也是容器。通过适配器Adapter（后面会讲解）提供“多表项”，利用AdapterView的setAdapter(Adapter)方法将“多表项”加入AdapterView容器中。 AdapterView派生的三个类AbsListView、AbsSpinner和AdapterViewAnimator依然是抽象类，所以实际开发中使用的是它们的子类。下面分别来看这些子类。 实际开发中ListView是最常用的组件之一，ListView以垂直列表的形式显示所有列表项。其实除了利用ListView生成列表视图之外，还可以让Activity直接继承ListActivity，这里暂不提这种形式。 当程序中使用了ListView“容器”之后，就需要为容器中加内容，添加的内容由Adapter提供。这一点也和AdapterView很相似：通过 setAdapter方法提供Adapter，并由该Adapter提供要显示的内容。 先来看AbsListView提供的常用XML属性，如表所示。 如果想对ListView进行外观和行为的定制，就需要把ListView作为AdapterView来使用，然后通过Adapter控制每个列表项的外观和行为。 Adapter接口及其实现类 Adapter本身只是一个接口，它派生了两个子类：ListAdapter和SpinnerAdapter类，具体的派生类及继承关系如图所示： 在上图中，几乎所有的Adapter都继承了BaseAdapter，而BaseAdapter继承了ListAdapter和SpinnerAdapter接口，因此BaseAdapter及其子类都可以为AbsListView或AbsSpinner提供列表项。 Adapter常用的实现类如下： ArrayAdapter：通常用于将数组或List集合的多个值包装成多个列表项。 SimpleAdapter：功能强大的Adapter，将List集合的多个对象包装成多个列表项。 SimpleCursorAdapter：与SimpleAdapter很相似，只是用于包装Cursor提供的数据。 BaseAdapter：通常用于扩展的Adapter，扩展后的Adapter可以对各列表项定制。 这里要注意，使用SimpleAdapter时有5个参数需要填写，其中后面4个非常关键。 第2个参数：List> data。它是一个List类型的集合对象，该集合中每个Map对象生成一个列表项. 第3个参数：int resource。该参数指定一个界面布局的ID。本例中指定为R.layout.simple_layout，即使用app\\src\\main\\res\\layout\\simple_layout.xml文件作为列表项组件. 第4个参数：String[] from。决定提取Map对象中哪些key对象的value来生成列表项。 第5个参数：int[] to。决定填充哪些组件。 扩展BaseAdapter需要重写以下4个方法。 getCount()：该方法的返回值控制该Adapter包含多少项。 getItem()；该方法的返回值决定第position处的列表项内容。 getItemId()：该方法的返回值决定第position处的列表项ID。 getView()：该方法的返回值决定第position处的列表项组件。 4个方法中最重要的是第1个和第4个方法。需要说明的是，虽然此处只是介绍了ListView，但是也同样适用于AdapterView的其他子类，如GridView、Spinner等。 主要介绍了Android程序中的界面编程，先介绍基本的界面和视图的使用方式，接着讲解6种常用的布局管理器，最后讲解了三种常用的UI组件和一个Adapter接口。学习完本章内容，大家需动手进行实践，为后面学习打好基础。 需要指出的是，本小节内容很重要，实际开发中会经常使用到适配器Adapter。所以希望大家好好体会练习。 常见的UI组件介绍 菜单 Android中的菜单（menu）在桌面应用中十分广泛，几乎所有的桌面应用都会使用到。Android应用中的菜单分为三种：选项菜单（ OptionMenu ）、上下文菜单（ ContextMenu ）、弹出式菜单（ PopupMenu ），本节依次介绍这些内容。 选项菜单 从Android3.1开始引入了全新的操作栏，扩展了很多功能，例如安置菜单选项、配置应用图标作为导航按钮等。 可显示在操作栏上的菜单称为选项菜单（OptionMenu）。选项菜单提供了一些选项，用户选择后可进行相应的操作。 一般为Android应用添加选项菜单的步骤如下： （1）重写Activity的onCreateOptionsMenu(Menu menu)方法，在该方法里调用Menu对象的方法添加菜单项。 （2）如果想要引用程序响应菜单项的单击事件，就要继续重写Activity的onOptionsItemSelected(MenuItem mi)方法。 添加菜单项的方式与UI组件的使用方式一样，可以在代码中使用也可以在XML布局文件中使用。Android同样推荐在XML中使用菜单，具体为在app\\src\\main\\res文件夹中创建名称为menu的文件夹，创建完成之后在menu文件夹中新建根标签为menu的布局文件，来看具体的示例代码： XML文件中的选项菜单options_menu.xml 菜单定义完成之后需要在代码中使用才可以看到效果，Java代码如下： 上面代码中第8行和第13行，包含显示菜单和响应菜单单击事件的两个方法。实现简单的选项菜单。 一个简单的选项菜单示例就完成了。下面来分析Menu的组成结构。 Menu接口是一个父接口，该接口下实现了两个子接口。 SubMenu：代表一个子菜单，可包含1~N个MenuItem（形成菜单项）。 ContextMenu：代表一个上下文菜单，可包含1~N个MenuItem（形成菜单项）。 Menu接口定义了add()方法用于添加菜单项，addSubMenu()方法用于添加子菜单项。只不过有好几个重载方法可供选择，使用时可根据需求选择。SubMenu继承自Menu，它额外提供了setHeaderIcon、setHeaderTitle、setHeaderView方法，分别用于设置菜单头的图标、标题以及设置菜单头。 上下文菜单 ContextMenu继承自Menu，开发上下文菜单（ContextMenu）与开发选项菜单基本类似，区别在于：开发上下文菜单是重写onCreateContextMenu(ContextMenu menu, View source, ContextMenu.ContextMenuInfo menuInfo)方法，其中source参数代表触发上下文菜单的组件。 开发上下文菜单的步骤如下： （1）重写Activity的onCreateContextMenu(…)方法. （2）调用Activity的registerForContextMenu(View view)方法为view注册上下文菜单. （3）如果想实现点击事件，需要重写onContextItemSelected(MenuItem mi)方法 与SubMenu子菜单相似，ContextMenu也提供了setHeaderIcon与setHeaderTitle方法为ContextMenu设置图标和标题。 弹出式菜单 默认情况下，弹出式菜单（ PopupMenu ）会在指定组件的上方或下方弹出。PopupMenu可增加多个菜单项，并可为菜单项增加子菜单。 使用PopupMenu的步骤与前两种Menu不同，具体步骤如下。 （1）调用new PopupMenu(Context context, View anchor)创建下拉菜单，anchor代表要激发弹出菜单的组件。 （2）调用MenuInflater的inflate()方法将菜单资源填充到PopupMenu中。 （3）调用PopupMenu的show()方法显示弹出式菜单。 设置与菜单项关联的Activity 前两种菜单创建时非常相似，只有弹出式菜单创建时比较特殊。在实际开发中这三种菜单会经常使用，本章中的例子希望读者能动手练习并掌握其用法。讲解完使用方式之后，下面再来看一个小知识点：在菜单项中启动另外一个Activity（或Service）。 在实际开发中会经常碰到这样一种情况：点击某个菜单项后跳转到另外一个Activity（或者Service）。对于这种需求，Menu中也有直接的方法可以使用。开发者只需要调用MenuItem的setIntent(Intent intent)方法就可以把该菜单项与指定的Intent关联到一起，当用户单击该菜单项时，该Intent所包含的组件就会被启动。 对话框的使用 在日常的App使用中经常看到对话框，可以说对话框的出现使得App不再那么单调。Android中提供了丰富的对话框支持，日常开发中会经常使用到如下表所示对的4种对话框。 使用功能AlertDialog建立对话框 AlertDialog是上述4种对话框中功能最强大、用法最灵活的一种，同时它也是其他3种对话框的父类。 使用AlertDialog生成的对话框样式多变，但是基本样式总会包含4个区域：图标区、标题区、内容区、按钮区。 创建一个AlertDialog一般需要如下几个步骤： （1）创建AlertDialog.Builder对象。 （2）调用AlertDialog.Builder的setTitle()或setCustomTitle()方法设置标题。 （3）调用AlertDialog.Builder的setIcon()设置图标。 （4）调用AlertDialog.Builder的相关设置方法设置对话框内容。 （5）调用AlertDialog.Builder的setPositiveButton()、setNegativeButton()或setNeutralButton()方法添加多个按钮。 （6）调用AlertDialog.Builder的create()方法创建AlertDialog对象，再调用AlertDialog对象的show()方法将该对话框显示出来。 AlertDialog的样式多变，就是因为设置对话框内容时的样式 多变，AlertDialog提供了6种方法设置对话框的内容，如表所示。 创建DatePickerDialog与TimePickerDialog对话框 DatePickerDialog与TimePickerDialog的功能较为简单，用法也简单，使用步骤如下： （1）通过new关键字创建DatePickerDialog、TimePickerDialog实例，然后调用它们自带的show()方法即可将这两种对话框显示出来。 （2）为DatePickerDialog、TimePickerDialog绑定监听器，这样可以保证用户通过DatePickerDialog、TimePickerDialog设置事件时触发监听器，从而通过监听器来获取用户设置的事件。 创建ProgressDialog进度对话框 程序中只要创建了ProgressDialog实例并且调用show()方法将其显示出来，进度对话框就已经创建完成。在实际开发中，会经常对进度对话框中的进度条进行设置，设置的方法有如表所示。 关于PopupWindow及DialogTheme窗口 PopupWindow顾名思义是弹出式窗口，它的风格与对话框很像，所以和对话框放在一起来讲解。使用PopupWindow创建一个窗口的步骤如下： （1）调用PopupWindow的构造方法创建PopupWindow对象。 （2）调用其自带的showAsDropDown(View view)方法将PopupWindow作为view的下拉组件显示出来；或调用showAtLocation()方法在指定位置显示该窗口。 ProgressBar及其子类 在实际开发中，ProgressBar也是经常用到的进度条组件，它派生了两个常用的子类组件：SeekBar与RatingBar。Progress及其子类在用法上很相似，只是显示界面有一定的区别。它们的继承关系如图所示： 进度条的功能和用法 进度条（ProgressBar）在实际开发中会经常用到，通常用于向用户展示耗时操作完成的百分比，避免让用户觉得程序无响应，对提升用户体验有很大帮助。 通常应用中见到的ProgressBar有两种形式：水平型与环形进度条。可通过如下属性值获得需要的形状，如表所示。 ProgressBar设置了两个方法来操作进度条： （1） setProgress(int value)：设置已完成的百分比. （2） incrementProgressBy(int value)：设置进度条的进度增加或减少。 ProgressBar支持的属性，如表所示： 拖动条的功能和用法 拖动条（SeekBar）是允许用户拖动来改变滑块的位置，从而改变相应的值。这一点与进度条是不一样的，而且拖动条也没有利用颜色来区别不同的区域。因此拖动条通常用于对系统的某种数值进行调节，例如调节音量。 由于SeekBar继承自ProgressBar，因此它支持ProgressBar中的全部属性和方法，除此之外，增加了改变滑动块外观的属性android:thumb，该属性指定了一个Drawable对象。滑动时，通过onSeekBarChangeListener监听器改变系统的值。 星级评分条的功能和用法 星级评分条（ RatingBar ）与SeekBar的用法和功能特别相似，最大的区别是外观：RatingBar通过拖动星数来表示进度。它常用的属性有如下几种： android:isIndicator：设置该星级评分条是否允许用户改变。 android:numStars：设置总共有多少星级。 android:rating：设置默认的星级数。 android:stepSize：设置每次最少需要改变多少星级。 同SeekBar一样，拖动RatingBar时需要设置监听器 onRatingBarChangeLinstener。 "},"page/1006.html":{"url":"page/1006.html","title":"(基本)组件","keywords":"","body":"基本组件 Android应用程序通常由一个或多个基本组件组成，之前创建的项目时就用到了Activity组件。 其实Android基本组件还包括Service、BroadcastReceiver、ContentProvider等组件，这四大组件也是日后做安卓开发时经常用到的。 Activity和View Activity是Android应用中负责与用户交互的组件，凡是在应用中看到的界面，都是在Activity中显示。前面提过，Activity通过setContentView(View)方法显示指定的组件。 View组件是所有UI组件和容器控件的基类，它是App中用户能看到的部分。View组件是放在容器组件中，或是使用Activity将其显示出来。如果需要通过某个Activity把指定View显示出来，调用Activity的setContentView()方法即可。 若一个Activity中没有调用setContentView()方法来显示指定的View，那么该页面将会显示一个空窗口。 Activity还包含了一个setTheme(int resid)方法，它用来设置对应的Activity的主题风格。比如不希望该Activity显示ActionBar、或以dialog形式显示等，都可以通过该方法来设置。 Service Service与Activity相比，可以把Service看作是没有View的Activity，事实上Service也没有可以设置显示View的方法。因为不用显示View，也就不需要与用户交互，故它一般在后台运行，用户是看不到它的。 BroadcastReceiver BroadcastReceiver翻译过来就是广播接收器，事实上它在Android中作用也是广播。从代码实现的角度来看，BroadcastReceiver非常类似于事件编程中的监听器，但两者的区别在于，普通事件监听器监听的事件源是程序中的对象，而广播接收器监听的事件源是Android应用中的其他组件。 实现BroadcastReceiver的方式很简单，开发者只要编写继承BroadcastReceiver的类，并重写onReceiver()方法就可以了。但是这只是接收器，那接收的消息从哪里来呢？当其他组件通过sendBroadcast()、sendStickyBroadcast()或sendOrderedBroadcast()方法发送广播消息时，如果接收广播的组件中实现的BroadcastReceiver子类有对应的Action(通过IntentFilter的setAction设置)，那么就可以在onReceiver()方法中接收该消息。 实现BroadcastReceiver子类之后，需要在AndroidManifest.xml中注册才能使用该广播。那么BroadcastReceiver如何注册呢？有两种注册方式： （1）在Java代码中通过Context.registerReceiver()方法注册； （2）在AndroidManifest.xml中通过元素完成注册。 这里只是让大家对BroadcastReceiver有一个大致的了解，在后面的章节中会详细介绍。 ContentProvider 在Android平台中，ContentProvider是一种跨进程间通信。比如当发送短信时，需要在联系人应用中读取指定联系人的数据，这时就需要两个应用程序之间进行数据交换。而ContentProvider提供了这种数据交换的标准。 当开发者实现ContentProvider时，需要实现如下抽象方法： （1）insert(Uri,，ContentValues)：向ContentProvider插入数据； （2）delete(Uri，ContentValues)：删除ContentProvider中指定的数据； （3）update(Uri，ContentValues，String，String[])：更新ContentProvider指定的数据； （4）query(Uri，String[]，String，String[]，String)：查询数据。 通常与ContentProvider结合使用的是ContentResolver，一个应用程序使用ContentProvider暴露自己的数据，而另一个应用程序则通过ContentResolver来访问程序。 Intent和IntentFilter 这两个并不是Android应用的组件，但它对Android应用的作用非常大——它是Android应用内不同组件之间通信的载体。当一个Android应用内需要有不同组件之间的跳转，例如一个Activity跳转到另一个Activity，或者Activity跳转到Service时，甚至发送和接收广播时，都需要用到Intent。 Intent封装了大量关于目标组件的信息，可以利用它启动Activity、Service或者BroadcastReceiver。一般称Intent为“意图”，意图可以分为两类： （1）显式Intent：明确指定需要启动或者触发的组件的类名。 （2）隐式Intent：指定需要启动或者触发的组件应满足怎样的条件。 对于显式Intent，Android系统无须对该Intent做出任何解析，系统直接找到指定的目标组件，启动或者触发它即可。 而对于隐式Intent，Android需要解析出它的条件，然后再在系统中查找与之匹配的目标组件。若找到符合条件的组件，就启动或触发它们。 那么Android系统如何判断是隐式Intent还是显示Intent呢？就是通过IntentFilter来实现的。被调用的组件通过IntentFilter声明自己满足的隐式条件，使系统可以拿来判断是否启动这个组件。关于这个知识点的详细内容，在后面的内容中会详细介绍。 "},"page/1007.html":{"url":"page/1007.html","title":"Activity和Fragment","keywords":"","body":"Activity和Fragment Activity的建立与使用 Activity介绍 Activity直接或间接继承了Context、ContextWrapper、ContextThemeWrapper等基类。 在使用Activity时，需要开发者继承Activity基类。在不同的应用场景下，可以选择继承Activity的子类。 例如界面中只包括列表，则可以继承ListActivity；若界面需要实现标签页效果，则要继承TabActivity。 当一个Activity类被定义之后，这个Activity类何时被实例化，它所包含的方法何时被调用，都是由Android系统决定的。开发者只负责实现相应的方法创建出需要的Activity即可。 创建一个Activity需要实现一个或多个方法，其中最基本的方法是onCreate(Bundle status)方法，它将会在Activity被创建时回调，然后通过setContentView(View view)方法显示要展示的布局文件。 配置Activity Activity必须在AndroidManifest.xml清单文件中配置才可以使用，而在Android Studio中是自动配置完成，但是有时自动配置完成的属性并不能满足需求。配置Activity时常用的属性如表所示。 除了上面几个属性之外，Activity中还可以设置一个或多个元素，该元素用于指定该Activity可响应的Intent。 Activity的启动与关闭 在一个Android应用程序中通常会有多个Activity，每个Activity都是可以被其他Activity启动的，但程序只有一个Activity作为入口，即程序启动时只会启动作为入口的Activity，其他Activity会被已经启动的其他Activity启动。 Activity被启动的方式有以下两种： startActivity(Intent intent)：启动其他Activity。 startActivityForResult(Intent intent, int requestCode)：以指定的请求码(requestCode)启动新Activity，并且原来的Activity会获取新启动的Activity返回的结果（需重写onActivityResult(…)方法）。 启动Activity有两种方式，关闭Activity也有两种方式： finish()：关闭当前Activity。 finishActivity(int requestCode)：结束以startActivityForResult(Intent intent, int requestCode)方法启动的Activity。 要注意的是显式启动时用setClassName(String packageName, String className)方法，第一个参数是包名，第二个参数是类的全路径名。隐式启动的方式之前没有例子涉及到，它需要在清单文件中对应的Activity中设置action标签，并且与代码中的setAction()中设置的内容一样。 其实隐式启动时Android系统会根据清单文件中设置的action、category、uri找到最合适的组件，只不过本例中设置category为\"android.intent.category.DEFAULT\"是一种默认的类别，在调用startActivity()时会自动将这个category添加到Intent。 Activity的显示启动与隐式启动，两个Activity之间切换 使用Bundle在Activity之间交换数据 在实际开发中，一个Activity启动另一个Activity时经常需要传输数据过去。在Activity之间交换数据很简单，使用Intent即可。在启动新的Activity时，利用Intent提供的多种方法将数据传递过去。常用的方法如表所示。 Intent主要通过Bundle对象来携带数据，使用到的方法都在上面表中。 Activity的生命周期与启动模式 Activity的生命周期演示 当一个Android应用运行时，Android系统以Activity栈的形式管理应用中的全部Activity，随着不同应用的切换或者设备内存的变化，每个Activity都可能从活动状态变为非活动状态。这个变化过程就涉及到Activity的部分甚至全部生命周期。 Activity的生命周期分为4种状态，分别如下。 （1）运行状态：当前Activity位于前台，用户可见，可以获取焦点。 （2）暂停状态：其他Activity位于前台，该Activity依然可见，只是不能获取焦点。 （3）停止状态：该Activity不可见，失去焦点。 （4）销毁状态：该Activity结束，或所在的进程结束。 Activity的生命周期包含如表所示的方法。 在实际开发中使用Activity时根据实际需要选择重写指定的方法即可。比如前面的很多实例中，绝大部分都只重写了onCreate(Bundle savedStatus)方法，该方法用于对Activity的初始化。 另外需要注意的是，在实际开发中会遇到横竖屏切换的问题。在例4-8中已经讲了横竖屏切换时设置的问题。当手机横竖屏切换时，Activity的生命周期可能会销毁重建。 如果不希望横竖屏切换时生命周期销毁重建，可以设置对应Activity的android:configChanges属性，具体代码如下： android:configChanges=\"orientation|ketboardHidden|screenSize\" 如果希望某个界面不随手机的晃动而切换横竖屏，可以参考如下设置： android:screenOrientation=\"portait\" //竖屏 android:screenOrientation=\"landscape\" //竖屏 Activity的4种启动模式 配置Activity时的属性lanuchMode——启动模式。该属性支持4种属性值。如表所示。 例如：android:launchMode=singleTop Android系统以栈(Task)的形式管理应用中的Activities：先启动的Activity放在Task栈底，后启动的Activity放在Task栈顶，满足“先进后出”的原则。 Activity的启动模式，就是负责管理Activity的启动方式、已经实例化的Activity，并控制Activity与Task之间的加载关系。 下面详细介绍这4种启动模式。 1.standard模式 standard模式是默认的启动模式，当一个Activity在清单文件中没有配置launchMode属性时默认就是standard模式启动。 在这种模式下，每次启动目标Activity时，Android总会为目标Activity创建一个新的实例，并将该实例放入当前Task栈中（还是原来的Task栈，并没有启动新的Task）。 2.singleTop模式 这种模式与standard模式很相似，不同点是：当要启动的目标Activity已经位于栈顶时，系统不会重新创建新的目标Activity实例，而是直接复用栈顶已经创建好的Activity。 不过要注意的是，如果要启动的目标Activity不是位于栈顶，那么系统将会重新实例化目标Activity，并将其加入Task栈中，这时singleTop模式与standard模式完全一样。 3.singleTask模式 当一个Activity采用singleTask启动模式后，整个Android应用中只有一个该Activity实例。 系统对它的处理方式稍显复杂，首先检查应用中是否有该Activity的实例存在，如果没有，则新建一个目标Activity实例；如果已有目标Activity存在，则会把该目标Activity置于栈顶，在其上面的Activity会全部出栈。 4.singleInstance模式 设置为 singleInstance 模式的 Activity 将独占一个任务栈task，此时可以把该Activity看作是一个应用，这个应用与其他Activity是相互独立的，它有自己的上下文Activity。 例如，现有以下三个Activity: Act1、Act2、Act3，其中Act2 为 singleInstance 模式。它们之间的跳转关系为： Act1 → Act2 → Act3 ，现在在Act3中按下返回键，由于Act2位于一个独立的task中，它不属于Act3的上下文activity，所以此时将直接返回到Act1。这就是singleInstance模式。 Fragment的建立与使用 Fragment代表Activity的子模块，是Activity界面的一部分或一种行为。Fragment拥有自己的生命周期，也可以接收自己的输入事件。 Fragment与Activity关系 Fragment是依赖于Activity的，不能独立存在的。 一个Activity里可以有多个Fragment。 一个Fragment可以被多个Activity重用。 Fragment有自己的生命周期，并能接收输入事件。 能在Activity运行时动态地添加或删除Fragment。 Fragment的优势有以下几点： 模块化（Modularity）：不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。 可重用（Reusability）：多个Activity可以重用一个Fragment。 可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。 Fragment的生命周期 与Activity一样，Fragment也有自己的生命周期，如图所示。 在上图中展示了Fragment生命周期中被回调的所有方法。 onCreate(Bundle saveStatus)：创建Fragment时被回调，该方法只会被回调一次。 onCreateView()：每次创建、绘制该Fragment的View组件时回调该方法，Fragment将会显示该方法返回的View组件。 onActivityCreated()：当Fragment所在的Activity被启动完成后回调该方法。 onStart()：启动Fragment时回调该方法。 onResume()：恢复Fragment时被回调，在onStart()方法后一定会回调该方法。 onPause()：暂停Fragment时被回调。 onDestroyView()：销毁该Fragment所包含的View组件时被回调。 onDestroy()：销毁该Fragment时被回调。 onDetach()：将该Fragment从宿主Activity中删除、替换完成时回调该方法，在onDestroy()方法后一定会回调onDetach()方法，且只会被回调一次。 与开发Activity时一样，开发Fragment时也是根据需要选择指定的方法进行重写，Fragment中最常被重写的方法是onCreateView()。 创建Fragment 与创建 Activity 类似，开发者实现的 Fragment 必须继承 Fragment 基类 接下来实现 Fragment 与实现 Activity 非常相似，它们都需要实现与 Activity 类似的回调方法，例如 onCreate() 、 onCreateView() 、 onStart() 、 onResume() 、 onPause() 、 onStop() 等。 对于大部分 Fragment 而言，通常都会重写onCreate() 、 onCreateView() 和onPause() 这三个方法，实际开发中也可以根据需要重写 Fragment 的任意回调方法。 Fragment与Activity通信 在Activity中显示Fragment则必须将Fragment添加到Activity中。将Fragment添加到Activity中有如下两种方式： 在布局文件中添加：在布局文件中使用元素添加Fragment,其中 的android:name属性必须指定Fragment的实现类。 在Java代码中添加：Java代码中通过FragmentTransaction对象的relpace()或add()方法来替换或添加Fragment。 在第二种方式中，Activity的getFragmentManager()方法返回FragmentManager，通过调用FragmentManager的beginTransaction()方法获取FragmentTransaction对象。 要实现Activity与Fragment通讯，首先需要获取对应的对象。在Activity中获取Fragement，以及在Fragment中获取Activity的方法如下。 （1）Fragment获取它所在的Activity：调用Fragment的getActivity()方法即可返回它所在的Activity。 （2）Activity获取它包含的Fragment：调用Activity关联的FragmentManager的findFragmentByld(int id)或findFragmentByTag(String tag)方法即可获取指定的Fragment。 在界面布局文件中使用 元素添加Fragment时，可以为 元素指定android:id或android:tag属性，这两个属性都可用于标识该Fragment，接下来Activity将可通过findFragmentByld(int id)或findFragmentByTag(String tag)来获取该Fragment。 考虑到有Activity与Fragment互相传递数据的情况，可以按照以下三种方式进行。 （1）Activity向Fragment传递数据：在Activity中创建Bundle数据包，并调用Fragment的setArguments(Bundle bundle)方法即可将Bundle数据包传给Fragment。 （2）Fragment向Activity传递数据或Activity需要在Fragment运行中进行实时通信：在Fragment中定义一个内部回调接口，再让包含该Fragment的Activity实现该回调接口，这样Fragment即可调用该回调方法将数据传给Activity。 （3）通过广播的方式。 Fragment管理与Fragment事务 Activity管理Fragment主要依靠FragmentManager。 FragmentManager的功能如下。 （1）使用findFragmentByld()或findFragmentByTag()方法来获取指定Fragment。 （2）调用popBackStack()方法将Fragment从后台找到弹出(模拟用户按下Back键)。 （3）调用addOnBackStackChangeListener()注册一个监听器，用于监听后台栈的变化。如果需要添加、删除、替换Fragment，则需要借助FragmentTransaction对象，该对象代表Activity对Fragment执行的多个改变。 每个FragmentTransaction可以包含多个对Fragment的修改，比如包含调用多个add()、replace()、和remove()操作，最后调用commit()提交事务即可。 在调用commit()之前，开发者也可调用addToBackStack()将事务添加到back栈，该栈由Activity负责管理，这样允许用户按BACK按键返回到前一个Fragment状态。 在上面的示例代码中，newFragment替换了当前界面布局中ID为fragment_container的容器内的Fragment，由于程序调用了addToBackStack()将该replace操作添加到了back栈中，因此用户可以通过按下返回键返回替换之前的状态。 "},"page/1008.html":{"url":"page/1008.html","title":"Service","keywords":"","body":"Service "},"page/1009.html":{"url":"page/1009.html","title":"BroadcastReceiver","keywords":"","body":"BroadcastReceiver "},"page/1010.html":{"url":"page/1010.html","title":"ContentProvider","keywords":"","body":"ContentProvider 使用ContentProvider实现数据共享 数据共享标准：ContentProvider ContentProvider简介 ContentProvider内容提供者作为Android四大组件之一，其作用是在不同的应用程序之间实现数据共享的功能。 ContentProvider可以理解为一个Android应用对外开放的数据接口，只要是符合其定义的URI格式的请求，均可以正常访问其暴露出来的数据并执行操作。其他的Android应用可以使用ContentResolver对象通过与ContentProvider同名的方法请求执行。ContentProvider有很多对外可以访问的方法，并且在ContentResolver中均有同名的方法，它们是一一对应的，如图所示。 具体ContentProvider如何使用呢？步骤如下所示。 （1）定义自己的ContentProvider类，该类需要继承Android提供的ContentProvider基类。 （2）在AndroidManifest.xml文件中注册这个ContentProvider，与注册Activity方式类似，只是注册时需要为它指定authorities属性，并绑定一个URI。 例如： 注意上面代码中authorities属性即指定URI。 结合上图，在自定义ContentProvider类时，除了需要继承ContentProvider之外，还要重写一些方法才能暴露数据的功能。方法如表所示。 从表中的各个方法可以看出，URI是一个非常重要的概念，下面详细介绍关于URI的知识。 URI简介 在第6章介绍Intent的Data属性时，简单讲解了URI。这里来做详细讲解。 URI代表了要操作的数据，URI主要包含了两部分信息： （1）需要操作的ContentProvider （2）对ContentProvider中的什么数据进行操作 而一个URI通常以下图所示的形式展示： ContentProvider（内容提供者）的scheme已经由Android规定为“content://”。主机名（或叫Authority）用于唯一标识该ContentProvider，外部调用者可以根据这个标识来找到它。 路径（path）可以用来表示我们要操作的数据，路径的构建应根据业务而定，例如： 操作person表中id为10的记录，可以构建这样的路径：/person/10。 操作person表中id为10的记录的name字段，构建路径：person/10/name。 操作person表中的所有记录，构建路径：/person。 操作xxx表中的记录，可以构建这样的路径：/xxx。 当然要操作的数据不一定来自数据库，也可以是文件、xml或网络等其他存储方式，例如： 操作xml文件中person节点下的name节点，需构建路径：/person/name。 如果要把一个字符串转换成URI，可以使用URI类中的parse()方法，如下： 使用ContentResolver操作数据 前面已经介绍过，调用者通过ContentResolver来操作ContentProvider暴露出来的数据，ContentResolver中的方法与ContentProvidert中的方法是一一对应的，不过与ContentProvider不同的是，获取ContentResolver对象是通过Context提供的getContentResolver方法。获取该对象之后，调用其包含的方法就可以操作数据。具体方法如表所示。 需要注意的是，ContentProvider一般是单例模式的，即当多个应用程序通过ContentResolver来操作ContentProvider提供的数据时，ContentResolver调用的数据将会委托给同一个ContentProvider处理。 开发ContentProvider 对初学者来说，理解ContentProvider暴露数据的方式是一个难点。其实，ContentProvider与ContentResolver就是通过URI进行数据交换。当调用者调用ContentResolver的CRUD方法进行数据的增删改查操作时，实际上是调用了ContentProvider中该URI对应的各个方法。 开发ContentProvider的子类 应用程序中的数据若想被其他应用访问并操作，就需要使用ContentProvider将其暴露出来。暴露方式就是开发ContentProvider的子类，并重写需要的方法。开发步骤如下： （1）新建一个类并继承ContentProvider，该类需要实现insert()、query()、delete()和update()等方法。 （2）将该类注册到AndroidManifest.xml文件中，并指定android:authorities属性。 在配置ContentProvider代码片段中经常使用如表所示几个属性。 在上面的配置代码中指定DemoProvider绑定了\"com.qianfeng.providers.demoprovider\"，该字符串就是URI的主机名部分，可根据它找到指定的ContentProvider。大家需要搞清楚的概念有以下两点： （1）ContentResolver调用方法时参数将会传给该ContentProvider的CRUD方法。 （2）ContentResolver调用方法的返回值，就是ContentProvider执行CRUD方法的返回值。 使用ContenResolver调用方法 前面已经提到，可通过Context提供的getContentResolver方法获取ContentResolver对象，获取该对象之后就可以调用其CRUD方法，而从前面的讲解中大家已经知道，调用ContentResolver的CRUD方法，实际上是调用指定URI对应的ContentProvider的CRUD方法。 操作系统的ContentProvider 在大家用过的手机APP中，肯定有要访问手机联系人的应用程序，有时还会操作联系人列表，比如添加联系人或读取联系人列表。该功能就需要调用系统ContentProvider提供的query()、insert()、update()和delete()方法，从而获取联系人列表数据用以操作。 系统ContentProvider同样提供了大量Uir供外部ContentResolver调用，大家可以查阅Android官方文档来获取这些信息。 使用ContentProvider管理联系人 在Android手机系统自带的应用中，都有“联系人”这一应用用于存储联系人电话、E-mail等信息。利用系统提供的ContentProvider，就可以在开发的应用程序中用ContentResolver来管理联系人数据。 Android系统用于管理联系人的ContentProvider的几个URI如下： ContactsContract.Contacts.CONTENT_URI：管理联系人的URI。 ContactsContract.CommonDataKinds.Phone.CONTENT_URI：管理联系人电话的URI。 ContactsContract.CommonDataKinds.Email. CONTENT_URI：管理联系人E-mail的URI。 注意查询和读取联系人信息是要获取权限，通过AndroidManifest.xml文件中设置如下权限代码： 从Android 6.0开始除了需要在清单文件中设置权限外，还需要在代码中动态请求权限，具体代码如例10-3中第16~25行所示。 使用ContentProvider管理多媒体 Android提供了Camera程序来支持拍照、拍摄视频，用户拍摄的照片、视频都将存放在固定的位置。在有些应用中，其他应用程序可能需要直接访问Camera所拍摄的照片、视频等，为满足这些需求，Android同样为这些多媒体内容提供了ContentProvider。 Android为多媒体提供的ContentProvider的URI如表所示。 与读取联系人信息一样，本程序读取SD卡中的图片信息同样需要权限，需要在AndroidManifest.xml文件中配置如下代码片段： 监听ContentProvider的数据改变 前面介绍的是当ContentProvider将数据共享出来后，ContentResolver会根据业务需要去主动查询ContentProvider所共享的数据。但有时应用程序需要实时监听ContentProvider所共享数据的改变，并随着ContentProvider数据的改变而提供响应，此时就需要使用ContentObserver。 前面介绍ContentProvider时，不管实现了insert()、delete()、update()或query()方法中的哪一个，只要该方法导致ContentProvider数据的改变，程序就会调用如下代码： 这行代码可用于通知所有注册在该URI上的监听者：该ContentProvider所共享的数据发生了改变。 为了在应用程序中监听ContentProvider数据的改变，需要利用Android提供的ContentObserver基类。监听ContentProvider数据改变的监听器需要继承ContentObserver类，并重写该基类所定义的onChange(boolean selfChange)方法，当ContentProvider共享的数据发生改变时，该onChange()方法将会被触发。 为了监听指定ContentProvider的数据变化，需要通过ContentResolver向指定的URI注册ContentObserver监听器，ContentResolver提供了如下方法来注册监听器。 上面的监听器中，uri表示该监听器监听的ContentProvider的URI；notifyForDescendents为false时表示精确匹配，即只匹配该URI，为true时表示可以同时匹配其派生的URI；observer即为该监听器的实例。 本程序需要读取系统短信的内容，因此需要在AndroidManifest.xml文件中配置如下权限： 其实监听用户短信详情使用上面程序的方式并不合适，因为必须让用户打开该应用才能监听到。在实际应用中，大多采用以后台进程的方式运行该监听方式，这就需要用到Android的另一个组件——Service，该组件将会在下一章内容中详细介绍。 本章主要介绍了Android系统中ContentProvider组件的功能和用法，ContentProvider是Android系统内不同进程之间进行数据交换的标准接口。学习本章需要重点掌握三个API的使用：ContentResolver、ContentProvider和ContentObserver。学习完本章内容，大家需动手进行实践，为后面学习打好基础。 "},"page/1011.html":{"url":"page/1011.html","title":"*Intent和IntentFilter","keywords":"","body":"Intent和IntentFilter 使用Intent和IntentFilter进行通信 Intent对象简述 这两个并不是Android应用的组件，但它对Android应用的作用非常大——它是Android应用内不同组件之间通信的载体。当一个Android应用内需要有不同组件之间的跳转，例如一个Activity跳转到另一个Activity，或者Activity跳转到Service时，甚至发送和接收广播时，都需要用到Intent。 Intent封装了大量关于目标组件的信息，可以利用它启动Activity、Service或者BroadcastReceiver。一般称Intent为“意图”，意图可以分为两类： （1）显式Intent：明确指定需要启动或者触发的组件的类名。 （2）隐式Intent：指定需要启动或者触发的组件应满足怎样的条件。 对于显式Intent，Android系统无须对该Intent做出任何解析，系统直接找到指定的目标组件，启动或者触发它即可。 而对于隐式Intent，Android需要解析出它的条件，然后再在系统中查找与之匹配的目标组件。若找到符合条件的组件，就启动或触发它们。 那么Android系统如何判断是隐式Intent还是显示Intent呢？就是通过IntentFilter来实现的。被调用的组件通过IntentFilter声明自己满足的隐式条件，使系统可以拿来判断是否启动这个组件。关于这个知识点的详细内容，在后面的内容中会详细介绍。 Activity、Service和BroadcastReceiver都是通过Intent启动，并且可以通过Intent传递数据。下表列出了使用Intent启动不同组件的方法。 关于Service与BroadcastReceiver的启动，在后面的章节中会详细讲解。这里只介绍Intent的相关内容。Intent包含的属性主要包括Component、Action、Category、Data、Type、Extra和Flag这7种属性。其中Extra属性在前面的很多示例中都有涉及，就不做介绍了。接下来详细介绍剩余6个属性的作用，以及使用示例。 Intent属性及intent-filter配置 Component属性 Component单词有“组件”的意思，顾名思义，使用Component属性时需要传入目标组件名，来看一个具体使用示例。 可以看到在上面第11-15行代码中，Component属性中指定了要启动的Activity名称，很明显这里采用了显式Intent启动Activity。在之前的例子中，也有很多采用显式Intent启动目标Activity的例子，可以发现在这些例子中，显式启动目标组件是以下的方式： Intent intent = new Intent(Context packageContext, Class cls); startActivity(intent); 显示启动明确指定了当前组件名与目标组件名。那么上面代码中的显式启动方式，与例6-1中的显式启动方式有什么区别呢？其实是一样的。例6-1中第11-15行首先创建了ComponentName对象，并将该对象设置成Intent对象的Component属性，这样应用程序即可根据该Intent “意图”启动指定的SecondActivity。当为Intent设置Component属性时，Intent提供了一个构造器用来直接指定目标组件名称。 当程序通过显式Intent（无论上面两种中的哪一种）启动目标组件时，被启动的组件不需要配置intent-filter元素就能被启动。 例6-1中的SecondActivity布局文件中只有一个TextView，这里不予展示，直接来看Java代码。 上面程序中第7行代码用来接收传过来的Component属性，TextView组件用于显示Component中的组件名和包名。 Action、Category属性与intent-filter Action与Category的属性值都是普通的字符串，其中Action设置Intent要完成的抽象动作，Category为Action添加额外的附加类别信息。通常这两个属性是结合使用的，在之前的很多示例中，观察对应的AnroidManifest.xml清单文件就会发现，凡是作为程序的入口Activity，都会配置以下几行代码： 上面代码中action与category都指定了name值，其中action指定name值为“android.intent.action.MAIN”，该值是Android系统指定程序入口时必须配置的。Category指定name值为“android.intent.category.LAUNCHER”，该值也是Android系统自带的，用于指定Activity显示顶级程序列表。 在例5-2中，演示了Activity的显式与隐式两种启动方式，其中隐式启动方式是在AndroidManifest.xml中为目标Activity配置Action，然后在上一个Activity对应的启动目标Activity代码处添加setAction方法，该方法里设置的值与配置的Action属性值必须是一致的。大家需要知道的是，这里的Action设置的name值是开发者自己添加的。 Android系统本身提供了大量标准的Action、Category常量，其中用于启动Activity的Action常量以及对应的字符串如下表所示。 上面两表列出来的只是部分常用的Action常量、Category常量。还有很多这两种常量没有介绍到，若大家有需要可去查看Android API文档中关于Intent的介绍。 需要指出的是，一个Intent对象最多只能包括一个Action属性，程序可调用Intent的setActio(String str)方法设置Action属性值；但是一个Intent对象可以包含多个Category属性，程序调用addCategory(String str)方法为Intent添加Category属性。当程序创建Intent时，系统默认为该Intent添加Category属性值为Intent.CATEGORY_DEFAULT的常量。 一般来说，使用Action与Category属性是为了隐式启动组件，无论是自己实现的组件还是系统组件。 Data、Type属性与intent-filter配置 Data属性通常用于向Action属性提供可操作的数据。Data属性接收一个URI对象，URI全称为Universal Resource Identifier，意为通用资源标识符，它代表要操作的数据，Android中可用的每种资源，包括图像、视频片段、音频资源等都可以用URI来表示。一般采用如下格式表示URI： scheme://host:port/path scheme是协议名称，常见的有content、market、http、file、svn等，当然也可以自定义，如支付宝使用alipay，迅雷使用thunder等。举一个URI的例子大家更容易理解，如某个图片的URI： content://media/external/images/media/4 上面一行代码中content代表scheme部分，media是host部分，port部分被省略，external/images/media/4是path部分。 Type属性用于指定该Data属性所指定URI对应的MIME类型。这种MIME类型可以是任意自定义的MIME类型，只要符合abc/xyz格式的字符串即可。MIME（ Multipurpose Internet Mail Extensions，多功能Internet 邮件扩充服务）是一种多用途网际邮件扩充协议，目前也应用到浏览器。 Data属性与Type属性是有执行顺序的，且后设置的会覆盖先设置的，如果希望Intent既有Data属性又有Type属性，则需要调用Intent的setDataAndType()方法。 Flag属性 Flag属性用于为该Intent添加一些额外的控制旗标，通过调用Intent的addFlags()方法来添加控制旗标。Android系统自带的Flag属性值有如表所示中的几个。 Android系统为Intent提供了大量的Flag，每个Flag都有其对应的功能，在实际开发中如果用到，请参考关于Intent的API官方文档。 "},"page/1012.html":{"url":"page/1012.html","title":"事件处理","keywords":"","body":"事件处理 Android事件处理 基于监听的事件处理 基于回调的事件处理 响应系统设置的事件 Handler消息传递机制 基于监听的事件处理 事件监听的处理模型 在事件监听的处理模型中，主要涉及三类对象： Event Source（事件源）：一般指各个组件。 Event（事件）：一般是指用户操作，该事件封装了界面组件上发生的各种特定事件。 Event Listener（事件监听器）：负责监听事件源所发生的事件，并对该事件做出响应。 实际上，事件响应的动作就是一组程序语句，通常以方法的形式组织起来。Android利用的是Java语言开发，其面向对象的本质没有改变，所以方法必须依附于类中才可以使用。而事件监听器的核心就是它所包含的方法，这些方法也被称为事件处理器(Event Handler)。 事件监听的处理模型可以这样描述：当用户在程序界面操作时，会激发一个相应的事件，该事件就会触犯事件源上注册事件监听器，事件监听器再调用对应的事件处理器做出相应的反应。 Android的事件处理机制采用了一种委派式的事件处理方式：普通组件（事件源）将整个事件处理委派给特定的对象（事件监听器），当该组件发生指定的事件时，就通知所委托的事件监听器，由该事件监听器处理该事件。该流程如图所示。 这种委派式的处理方式很类似于人类社会的分工合作。举一个简单例子，当人们想邮寄一份快递（事件源）时，通常是将该快递交给快递点（事件监听器）来处理，再由快递点通知物流公司（事件处理器）运送快递，而快递点也会监听多个物流公司的快递，进而通知不同的物流公司。这种处理方式将事件源与事件监听器分离，从而提供更好的程序模型，有利于提高程序的可维护性。 基于上面程序可以总结出基于监听的事件处理模型的编程步骤： （1）获取要被监听的组件（事件源）。 （2）实现事件监听器类，该类是一个特殊的Java类，必须实现一个XxxListener接口。 （3）调用事件源的setXxxListener方法将事件监听器对象注册给事件源。 当用户操作应用界面，触发事件源上指定的事件时，Android会触发事件监听器，然后由该事件监听器调用指定的方法（事件处理器）来处理事件。 实际上，对于上述三个步骤，最关键的步骤是实现事件监听器类。实现事件监听器其实就是实现了特定接口的Java类实例，在程序中实现事件监听器，通常有如下几种形式。 内部类形式：将事件监听器类定义成当前类的内部类。 外部类形式：将事件监听器类定义成一个外部类。 Activity本身作为事件监听器类：让Activity本身实现监听器接口，并实现事件处理方法。 匿名内部类形式：使用匿名内部类创建事件监听器对象。 创建监听器的几种形式举例 外部类形式创建监听器。 上面的事件监听器类实现了View.OnClickListener接口，创建该监听器时需要穿入一个Activity和一个TextView，来看具体Java代码： 上面程序第10行，用于给按钮的单击事件绑定监听器，当用户单击按钮时，就会触发监听器BtnClickListener，从而执行监听器里面的方法。 外部类形式的监听器基本就是这样实现，专门定义一个外部类用于实现事件监听类接口作为事件监听器，之后在对应的组件中注册该监听器。 Activity本身作为事件监听器类。 上面程序中Activity直接实现了View.OnClickListener接口，从而可以直接在该Activity中定onClick(View v)。当为某个组件添加该事件监听器的时候，直接使用this关键字作为事件监听器即可。 匿名内部类作为事件监听器。 可以看出匿名内部类的语法结构比较奇怪，除了这个缺点，匿名内部类相比于其他方式比较有优势，一般建议使用匿名内部类的方式创建监听器类。 在标签中绑定事件处理器 上面的布局文件中第20行，Button设置了onClick属性，这行代码就已经为Button绑定了一个事件处理方法：btnClick，这也意味着开发者需要在对应的Activity中定义一个void btnClick(View v)的方法，该方法将会处理Button上的点击事件，来看Activity中的代码。 上面程序中的第11行就是属性onClick对应的方法，当用户点击该按钮时，btnClick方法将会被触发进而处理此点击事件。 基于回调的事件处理 回调机制 前面提到监听机制是一种委派式的事件处理机制，事件源与事件监听器分离，用户触发事件源指定的事件之后，交给事件监听器处理相应的事件。而回调机制则完全相反，它的事件源与事件监听器是统一的，或者可以说，它没有事件监听器的概念。因为它可以通过回调自身特定的方法处理相应的事件。 为了实现回调机制的事件处理，需要继承GUI组件类，并重写对应的事件处理方法，其实就是第2章中讲到的自定义UI组件的方法。Android为所有的GUI组件提供了一些事件处理的回调方法，以View类为例，该类包含如下表所示方法。 就代码实现的角度而言，基于回调的事件处理模型更加简单。 基于回调的事件传播 开发者可控制基于回调的事件传播，几乎所有基于回调的事件处理方法都有一个boolean类型的返回值，该返回值决定了对应的处理方法能否完全处理该事件。当返回值为false时，表明该处理方法并未完全处理该事件，事件会继续向下传播；返回值为true时，表明该处理方法已完全处理该事件，该事件不会继续传播。因此对基于回调的事件处理方式而言，某组件上所发生的事件不仅会激发该组件上的回调方法，也会触发所在Activity的回调方法，只要该事件能传播到该Activity。 与监听机制对比 对比这两种事件处理模型，可以看出基于监听的事件处理模型比较有优势： 分工明确，事件源与事件监听器分来实现，可维护性较好。 优先被触发。 但在某些特定情况下，基于回调的事件处理机制能更好地提高程序的内聚性。 例如例2-1中， 就采用了回调的方式自定义了BallView类。通过为View提供事件处理的回调方法，可以很好的把事件处理方法封装在该View内部，从而提高程序的内聚性。 基于回调的事件处理更适合解决如例2-1事件处理逻辑比较固定的View。 响应系统设置的事件 在实际开发中，经常会遇到横竖屏切换的问题，在Android应用中横竖屏切换并不仅仅是设备屏幕的横竖屏切换，它还涉及Activity生命周期的销毁与重建的问题。所以当遇到类似横竖屏切换这样的系统设置问题时，应用程序就需要根据系统的设置做出相应的改变，这就是本节要讲述的内容。 Configuration类简介 Configuration类专门用来描述Android手机的设备信息，这些配置信息既包括用户特定的配置项，也包括系统的动态设备配置。 获取Configuration对象的方式很简单，只需要一行代码就可以实现： Configuration cfg = getResources().getCongigration(); 获取了该对象之后，就可以通过该对象提供的如表所示的属性来获取系统的配置信息。 onConfigurationChanged方法 在Android应用中，经常会看到应用程序为适应手机屏幕的横竖屏切换，也切换了横竖屏显示方式。实现此功能需要对屏幕的横竖屏变化进行监听，可以通过重写Activity的onConfigurationChanged(Configuration newConfig)方法实现监听。该方法是一个基于回调的事件处理方法：当系统设置发生变化时，该方法会被自动触发。 Handler消息传递机制 开发一款APP肯定都会涉及到更新UI的问题，而Android中规定：只允许UI线程修改Activity中的UI组件。 UI线程就是主线程，是随着应用程序启动而自动启动的一条线程，它主要负责处理与UI相关的问题，例如用户的单击操作、触摸屏操作以及屏幕绘图等，并把相关的事件分发到对应的组件进行处理。 既然Android官方规定只能在UI线程中更新UI组件，那是不是新启动的线程就无法动态改变UI组件的属性值了呢？答案当然是否定的。本节中的Handler消息传递机制就可以轻松解决这个问题。 Handler类简介 Handler类可以在新启动的线程中向主线程发送消息，主线程中获取到消息并处理相应操作，从而达到更新UI的效果。 Handler采用回调的方式处理新线程发送来的消息。当新启动的线程发送消息后，消息被发送到与之相关联的MessageQueue中，最后Handler不断从MessageQueue中获取并处理消息。Handler类包含如下方法用于发送、处理消息，如表所示。 借助于上面这些方法，就可以利用Handler实现消息的传递。 Handler通过重写handleMessage(Message msg)方法来接收新线程发送来的消息（被自动回调），而handleMessage(Message msg)方法存在于主线程中，因此可动态修改ImageView属性值。这样就实现了由新线程修改UI组件的效果。 Handler、Loop及MessageQueue三者的关系 前面提到新线程将消息发送至MessageQueue，然后Handler不断从MessageQueue中获取并处理消息。Handler从MessageQueue中读取消息就要用到Looper，Looper的loop方法负责读取MessageQueue中的消息，读取消息之后把消息发送给Handler来处理。 上图很好地展示了这三者之间的关系，可以看出，如果希望Handler正常工作，必须在当前线程中有一个Looper对象。而Looper的创建分为两种情况： （1）在主线程即UI线程中，系统已默认初始化了一个Looper对象，因此程序可直接创建Handler即可。 （2）开发者新建的子线程中，必须自己创建一个Looper对象并启动它，才可使用Handler。创建Looper对象调用它的prepare()方法即可。 下面来分别归纳一下这三者的作用，如表所示。 在新建的线程中使用Handler的步骤如下： （1）调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，Looper的构造方法会自动创建与之匹配的MessageQueue。 （2）Looper创建完成之后，开始创建Handler实例，并重写handleMessage()方法，该方法负责处理来自于其他线程的消息。 （3）调用Looper的loop()方法启动Looper。 "},"page/1014.html":{"url":"page/1014.html","title":"资源处理","keywords":"","body":"资源处理 "},"page/1015.html":{"url":"page/1015.html","title":"应用资源","keywords":"","body":"应用资源 Android应用资源概述 Android应用资源可分为两大类： 第一种是无法通过R资源清单类访问的原生资源，保存在assets目录下，应用程序需要通过AssetManager以二进制流的形式读取该资源。 第二种是可以通过R资源清单类访问的资源，保存在res目录下，AndroidSDK会在编译该应用时自动为该类资源在R.java文件中创建索引。 资源的类型以及存储方式 资源的存储方式主要针对在res目录下的资源，使用不同的子目录来保存不同的应用资源。当新建一个Android项目时，Android Studio在res目录下自动生成几个子目录，如图所示。 图中，drawable文件夹中存放各种位图文件，包括*.png、*.png、*.jpg、*.gif等，还包括一些XML文件；layout文件夹中存放各种用户界面的布局文件；menu文件夹中存放应用程序定义各种菜单的资源；mipmap文件夹中存放图片资源，按照同一种图片不同的分辨率存放在不同的mipmap文件夹下（这样做是为了让系统根据不同的屏幕分辨率选择相应的图片）；values文件夹中存放各种简单值的XML文件，包括字符串值、整数值、颜色值、数组等。 但在实际开发中，这些自动生成的文件夹有时候并不能满足需求，比如要使用动画效果时，需要定义属性动画或者补间动画的XML文件，此时就需要在res目录下新建两个文件夹，分别命名为anim和animator，其中anim目录用于放置补间动画的XML文件，animator目录用于放置属性动画的XML文件。另外，如果一个RadioButton按钮在不同状态下其对应的文字颜色也不同，此时就需要定义一个XML文件用于其颜色变化的设置与选择，而在res目录中就需要新建命名为“color”的子目录，用于放置该XML文件。 使用资源 介绍Android应用的界面编程时介绍，控制Android应用的UI界面有两种方式，一种是通过在XML文件中使用标签的方式来实现UI界面，另一种是在Java代码中直接创建UI界面。相对应地，在Android应用中使用资源也可分为在Java代码和XML文件中使用资源。下面来介绍这两种使用资源的方式。 在Java代码中使用资源 这种方式很常用，如以下代码所示。 在Android SDK编译项目时，会在资源清单项R类中为res目录下所有资源创建索引项，因此在Java代码中使用资源主要通过R类来完成。 在XML中使用资源 当定义XML资源文件时，其中的元素可能需要指定不同的值。比如上面提到的RadioButton组件，在选中状态下和未选中状态下其文字颜色是不同的。 字符串、颜色与样式资源 字符串、颜色与样式资源是Android Studio新建项目时默认新建的资源，它们对应的XML文件都放在/res/values目录下，其默认的文件名以及在R类中对应的内部类如表所示。 资源类型 资源文件的默认名 对应于R类中内部类的名称 字符串资源 /res/values/strings.xml R.string 颜色资源 /res/values/colors.xml R.color 尺寸资源 /res/values/styles.xml R.style 颜色值的定义 Android中的颜色值是通过红(Red)、绿(Green)、蓝(Blue)三原色以及一个透明度(Alpha)值来表示的，以#开头，后面拼接Alpha-Red-Green-Blue的形式。若Alpha值省略代表该色值完全不透明。 Android颜色值支持常见的4种形式： #RGB、#ARGB、#RRGGBB、#AARRGGBB， 其中A、R、G、B都代表一个十六进制的数，A代表透明度，R代表红色数值，G代表绿色数值，B代表蓝色数值。 定义字符串、颜色与样式资源文件 当用Android Studio新建一个Android项目后，在/res/values目录下默认创建上表所示的三个文件，分别用于放置对应的资源。这三个文件的根元素都是，只是内部元素不同而已。 如下文件是字符串资源文件。 可以看出字符串资源中每个元素定义一个字符串，并使用name属性定义字符串的名称，与中间的内容就是该字符串的值。 颜色资源文件如下。 与字符串资源类似，元素定义一个字符串常量，使用name属性定义颜色的名称，与中间的内容就是该颜色的值。 接着看样式资源文件。 与上面两种资源类似，样式资源也是以作为根标签，每个元素定义一个常量值，用name属性定义样式的名称，再用标签指定对应的样式值。在上面代码中可以看到在前面例子中引用的样式资源“MTabStyle”。 数组资源 Android中的数组资源与上面介绍的三种资源类似，也是放在/res/values目录中，该资源文件以arrays.xml命名。其根元素也是，不同的是子元素的使用，一般使用如表所示的三种子元素。 为了在Java代码中访问到定义好的数组，Resources提供了如表所示方法。 TypedArray代表一个通用类型的数组，该类提供了getXxx(int index)方法来获取指定索引处的数组元素。 使用Drawable资源 Drawable资源是Android应用中使用最广泛的资源，在前面已经介绍过在/res/drawable目录下可以放置图片资源也可以放置一些XML文件。实际上Drawable资源通常就保存在/res/drawable目录下，下面来详细介绍几种Drawable资源。 图片资源 图片资源的创建很简单，开发者只需要将符合格式的图片放入/res/drawable目录下，Android SDK就会在编译应用中自动加载该图片，并在R资源清单类中生成该资源的索引。需要注意的是，图片的命名格式必须符合Java标识符的命名规则，否则项目编译时会报错。 当系统在R资源清单类中生成了指定资源的索引后，就可以在Java代码中引用该图片资源，引用格式如下： R.drawable. 在XML中引用格式如下： @drawable/ 除此之外，为了在程序中获取实际的图片资源，Resources提供了Drawable getDrawable(int id)方法，该方法即可根据Drawable资源在R资源清单类中的ID来获取实际的Drawable对象。 StateListDrawable资源 StateListDrawable用于组织多个Drawable对象。使用selector实现RadioButton中文字颜色的切换，这里的selector就是StateListDrawable资源，StateListDrawable对象所显示的Drawable对象会随着目标组件状态的改变而自动切换。 现在大家已经知道，定义StateListDrawable对象的XML文件的根元素是，该元素可包含多个元素，且元素中可指定如表所示的几个属性。 关于元素中的属性还有很多，上表中只列举了常用的几种，大家可根据需要使用Android API查询。 AnimationDrawable资源 AnimationDrawable中是动画资源，Android中的动画在实际开发中会经常用到，本节只是先介绍一下如何定义AnimationDrawable资源。下面以补间动画为例开始讲解AnimationDrawable资源的使用，补间动画是在两个帧之间通过平移、变换计算出来的动画。 定义补间动画的XML资源文件以元素作为根元素，根元素下可以指定以下4个元素。 alpha：设置透明度的改变。 scale：设置图片进行缩放变换。 translate：设置图片进行位移变化。 rotate：设置图片进行旋转。 补间动画的XML资源是放在/res/anim/路径下，且该路径需要大家自行创建，Android Studio默认不会包含该路径。 补间动画是在两个关键帧间进行平移、变换设置的动画，通常这两个关键帧是指一个图片的开始状态和结束状态，通过设置这两个帧的透明度、位置、缩放比、旋转度，再设置动画的持续时间，Android系统会自动使用动画效果把这张图片从开始状态变换到结束状态。 使用原始XML资源 定义使用原始XML资源 在某些时候，Android应用有一些初始化的配置信息、应用相关的数据资源需要保存，Android推荐使用XML方式来保存它们，这种资源被称为原始XML资源。下面介绍如何定义、获取原始XML资源。 原始XML资源一般保存在/res/xml/路径下，而之前介绍的Android Studio新建项目时默认目录中，并没有包含该xml子目录，所以开发者需要手动创建xml子目录。创建成功之后，与前面介绍的资源引用方式一样，其引用方式也有两种。在XML中引用格式如下： @xml/file_name 在Java中引用格式如下： R.xml.file_name 获取实际的XML文档同样是通过Resources类中两个方法。 getXml(int id)：获取XML文档，并使用一个XmlPullParser来解析该XML文档，该方法返回一个解析器对象XmlResourceParser（该对象是XmlPullParser的子类）。 openRawResource(int id)：获取XML文档对应的输入流，返回InputStream对象。 Android系统默认使用内置的Pull解析器来解析XML文件，即直接调用getXml(int id)方法获取XML文档，并将其解析。除了Pull解析方式之外，还可以使用DOM方式和SAX方式对XML文档进行解析。 Pull解析采用事件处理的方式来解析XML文档，当Pull解析器开始解析之后，通过调用Pull解析器的next()方法获取下一个解析事件（开始文档、结束文档、开始标签、结束标签等），当处于某个元素处时，可调用XmlPullParser的getAttributeValue()方法来获取该元素的属性值，也可调用XmlPullParser的nextText()方法来获取文本节点的值。 如果采用DOM或者SAX方式解析XML资源，则需要调用openRawResource(int id)方法获取XML资源对应的输入流，通过这种方式可以自行解析器解析该XML资源。 使用原始XML文件 下面通过一个示例介绍使用Pull解析器来解析XML文件。在res目录下新建xml目录，并在xml中新建文件person_list.xml文件，如例所示。 新建好XML文件后就可以来解析，在java代码中使用如下。 上面程序中第19~45行代码用于不断获取Pull解析的解析事件，程序中通过while循环将整个XML文档解析出来。activity_main.xml布局文件中包含两个TextView控件，其中startPull设置了单击事件用于开始解析，showText则用于显示解析出来的内容。 样式和主题资源 样式和主题资源都用于对Android应用进行“美化”，只要充分利用Android应用中的样式和主题资源，大家就可以开发出美轮美奂的Android应用。 样式资源 样式资源是指在Android应用中为某个组件设置样式时，该样式所包含的全部格式将会应用于该组件，如前面例子中MTabStyle样式所示。 一个样式相当于多个格式的合集，其他UI组件通过style属性来指定样式。Android中的样式资源文件也放在/res/values/目录中，样式资源的根元素是，该元素内可包含多个子元素，而每个子元素就是定义一个样式。子元素指定如下两个属性： name：指定样式的名称。 parent：指定该样式所继承的父样式。当继承某个父样式时，该样式将会获得父样式中定义的全部格式，也可以选择覆盖父样式中的全部格式。 子元素中又包含多个项，每个定义一个格式项。例如如下样式资源文件。 一旦定义了上面的样式资源后，就可以通过如下语法格式在XML资源中使用。 @style/file_name 主题资源 与样式资源非常相似，主题资源的XML文件通常也放在/res/values目录下，主题同样使用元素来定义主题。但两者在使用的场所上有所区别，主题是在清单文件中使用，样式是在布局文件中使用，具体如下： （1） 主题不能作用于单个的View组件，主题应该对整个应用中的所有Activity起作用，或对指定的Activity起作用。（2） 主题定义的格式应该是改变窗口的外观的格式，例如窗口标题，窗口边框等。 下面通过一个实例来介绍主题资源的用法。该主题资源自定义了Activity中的Title大小和背景覆盖，定义主题的片段如下： 定义了上面主题后，接下来就可以在Java代码中使用该主题，例如如下代码： 上面程序是在代码中设置主题资源，大部分时候在AndroidManifest.xml文件中对指定应用、指定Activity应用主题更加简单。 本章主要介绍了Android应用资源的相关内容。Android应用资源是一种非常优秀、高度解耦的设计，通过使用资源文件，Android应用可以把各种字符串、图片、颜色、界面布局等交给XML文件配置管理，这样就避免了在Java代码中以硬编码的方式直接定义这些内容。学习完本章内容，需要掌握Android应用资源的存储文件、Android应用资源的使用方式，为后面学习打好基础。 "},"page/1013.html":{"url":"page/1013.html","title":"图形图像","keywords":"","body":"图形与图像处理 使用简单图片 在实际开发中应用到的图片不仅仅包括.png、.gif、.png、.jpg和各种Drawable系对象，还包括位图Bitmap，而且对图片的处理也是一个影响程序的高效性和健壮性的重要因素。在第8章已经讲解过Drawable资源，下面讲解与之相关的两个类——Bitmap与BitmapFactory Bitmap代表一张位图，扩展名可以是.bmp或者.dib。位图是Windows标准格式图形文件，它将图像定义为由点（像素）组成，每个点可以由多种色彩表示，包括2、4、8、16、24和32位色彩。例如，一幅1024×768分辨率的32位真彩图片，其所占存储字节数为：1024×768×32/8=3072KB，虽然位图文件图像效果很好，但是非压缩格式的，需要占用较大存储空间，更不利于网络传输。利用Bitmap可以获取图像文件信息，借助Matrix进行图像剪切、旋转、缩放等操作，再以指定格式保存图像文件。 通常构造一个类的对象时，都是使用该类的构造方法实现。而Bitmap采用的是工厂设计模式而设计，所以创建Bitmap时一般不调用其构造方法，可通过如下两种方式构建Bitmap对象。 通过Bitmap的静态方法static Bitmap createBitmap() 通过BitmapFactory工厂类的static Bitmap decodeXxx() BitmapFactory是一个工具类，它用于提供大量的方法，这些方法可用于从不同的数据源来解析、创建Bitmap对象，BitmapFactory包含如表所示的常用方法。 在实际开发中，创建Bitmap对象时需考虑内存溢出（OutOfMemory，OOM）的问题，当上一个创建的Bitmap对象还没被回收而又创建下一个Bitmap对象时就会出现该问题。 为此Android提供了如下两个方法来判断Bitmap对象是否被回收，若没有则强制回收。 boolean isRecycled()：判断该Bitmap对象是否已被回收。 void recycle()：强制回收。 绘图 在第2章介绍Android应用的界面编程中，已经介绍了自定义UI组件的过程以及常用的继承方法。之所以需要自定义UI组件，是因为系统提供的原生组件并不能满足实际开发的需求。本节内容同理，绘图也是为了满足实际开发的需求。下面来讲解绘图时常用的几个类。 Android绘图基础：Canvas、Paint等 自定义View的三个方法都是被考查的关键，这三个方法分别是onMeasure()、onLayout()和onDraw()。 其中重写onDraw()方法时将用到Canvas类，Canvas单词本身有“油画布”的含义。Android通过Canvas类暴露了很多drawXXX方法，开发者可以通过这些方法绘制各种各样的图形。 Canvas绘图有三个基本要素：Canvas、绘图坐标系以及Paint。 Canvas是画布，通过Canvas的各种drawXxx方法将图形绘制到Canvas上面，在drawXxx方法中需要传入要绘制的图形的坐标形状，还要传入一个画笔Paint。drawXxx方法以及传入其中的坐标决定了要绘制的图形的形状，比如drawCircle方法，用来绘制圆形，需要传入圆心的x和y坐标，以及圆的半径。 drawXxx方法中传入的画笔Paint决定了绘制的图形的一些外观，比如绘制的图形的颜色，再比如绘制的是圆面还是圆的轮廓线等。 Android系统的设计吸收了很多现有系统的诸多优秀之处，比如Canvas绘图。Canvas不是Android所特有的，Flex和Silverlight都支持Canvas绘图，Canvas也是HTML5标准中的一部分，主流的现代浏览器都支持用JavaScript在Canvas上绘图，如果大家用过HTML5中的Canvas，就会发现与Android的Canvas绘图API很相似。 关于Canvas类的drawXxx方法以及Paint类的setXxx方法，大家可查阅相关API学习，这里简单介绍一些常用的方法。下表列出了Canvas类中的绘制方法。 下表列出了Canvas类中的绘制方法。 Path类 Path类是一个非常有用的类，它可以预先在View上将N个点连成一条“路径”，然后调用Canvas的drawPath(path，paint)方法即可沿着路径绘制图形。实际上除了Path类，Android还为路径绘制提供了PathEffect类来定义绘制效果，而PathEffect包含了如下几种绘制效果，每一种都是它的子类，具体如下： ComposePathEffect； CornerPathEffect； DashPathEffect； DiscretePathEffect； PathDashPathEffect； SumPathEffect。 图形特效处理 图形特效处理可以让开发者开发出更炫酷的UI界面，相比于前面介绍的图形支持，本节内容更适合开发一些特殊效果。 使用Matrix控制变换 Matrix单词是“矩阵”的意思，在Android中Matrix是一个3×3的矩阵，它对图片的处理有4个基本类型：平移（Translate）、缩放（Scale）、旋转（Rotate）、倾斜（Skew）。使用Matrix控制图形或组件变换的步骤如下： （1）获取Matrix对象； （2）设置即将要用的Matrix的方法； （3）将程序对Matrix所做的变换应用到指定图形或组件 Matrix提供了一些方法来控制图片变换，如表所示。 Matrix类位于android.graphics.Matrix包下，是Android提供的一个矩阵工具类，它本身并不能对图像或View进行变换，但它可与其他API结合来控制图形、View的变换，如Canvas。 图片在内存中存放的是一个个的像素点，而对于图片的变换主要就是处理图片的每个像素点，对每个像素点进行相应的变换，即可完成对图像的变换。 使用drawBitmapMesh扭曲图像 Mesh有“网状物”的意思，使用drawBitmapMesh扭曲图片，就是将图片分割成网格状，网格的交叉点就是需要获取的坐标点，获取之后改变坐标点，图片就会呈现不同的形状。“水波荡漾”、“风吹旗帜”等特效就是通过drawBitmapMesh方法实现的。 Canvas提供了drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint)方法，该方法关键参数的说明如下： bitmap: 指定需要扭曲的源位图。 meshWidth: 该参数控制在横向上把该源位图划分成多少格。 meshHeight: 该参数控制在纵向上把该源位图划分为多少格。 verts: 该参数是一个长度为(meshWidth + 1)(meshHeight+1) 2 的数组，它记录了扭曲后的位图各“顶点”位置。虽然它是一维数组，但是记录的数据是形如(x0, y0),(x1, y1),(x2, y2)......(xN, yN)格式的数据，这些数组元素控制对bitmap位图的扭曲效果。 vertOffset: 控制verts数组中从第几个数组元素开始才对bitmap进行扭曲(忽略vertOffset之前数据的扭曲效果)。 逐帧动画 逐帧动画是将每张静态图片快速播放，利用人眼的“视觉暂留”而给用户造成“动画”的错觉。 在Android中逐帧动画需要得到AnimationDrawable类的支持，AnimationDrawable类主要用来创建一个逐帧动画，并且可以对帧进行拉伸。在程序中获取AnimationDrawable对象后，把该对象设置为ImageView的背景即可使用AnimationDrawable.start()方法播放逐帧动画。 AnimationDrawable资源的使用很简单，在/res/drawable目录下新建XML文件，该文件以为根元素，使用子元素定义动画的全部帧。 补间动画 补间动画是指开发者只需设置动画开始、动画结束等关键帧，而动画变化的中间帧是由系统计算并补齐。 补间动画与插值器Interpolator 对补间（Tween）动画而言，开发者无须像逐帧动画那样定义动画过程中的每一帧，只要定义动画开始和结束的关键帧，并设置动画的持续时间即可。而中间的变化过程需要的帧是通过Animation类支持的。 Android中使用Animation代表抽象的动画类，它包括如表所示的几种子类。 一旦为补间动画指定三个必要信息，Android系统就会根据动画的开始帧、结束帧、持续时间计算出需要在中间“补入”多少帧，并计算所有补入帧的图形。 为了控制在动画期间需要动态“补入”多少帧，具体在动画运行的哪些时刻补入帧，需要借助插值器Interpolator。插值器的本质是一个动画执行控制器，它可以控制动画执行过程中速度变化，比如以匀速、加速、减速、抛物线速度等各种速度变化。 Interpolator是一个空接口，继承自TimeInterpolator。Interpolator接口中定义了 float getInterpolation(float input)方法，开发者可通过实现Interpolator来控制动画的变化速度。Android系统为Interpolator提供了几个常用实现类，分别用于实现不同的动画变化速度，如表所示。 在动画资源文件中使用上述实现类，只需要在定义补间动画的元素中使用android:interpolator属性，该属性的属性值可以指定Android默认支持的Interpolator，其格式为： 可以看出在资源文件中使用interpolator时，其格式与实现类的类名是对应的。资源文件定义完成之后，开发者需要在程序中通过AnimationUtils得到补间动画的Animation对象后，调用View的startAnimation(Animation anim)方法开始对该View执行动画即可。 位置、大小、旋转度与透明度改变的补间动画 在项目中一般采用动画资源文件来定义补间动画，本节来看一个示例，该示例是将一张图片从大到小缩放，期间结合旋转与透明度的设置，具体代码如例所示。 上面资源文件放置在/res/anim子目录下，命名为tween_anim.xml，该资源文件定义了缩放、透明度、旋转三种动画效果。 在该子目录下再定义一个命名为tween_anim_reverse.xml的资源文件，内容与tween_anim.xml中一样，但动画效果完全相反，大家只需把相应数值改变即可，这里不展示tween_anim_reverse.xml代码，Java代码如下。 上面Java代码首先通过AnimationUtils加载出动画资源，然后通过startAnimation()方法设置给ImageView动画效果。 属性动画 属性动画相比补间动画的功能更强大，主要表现在以下两方面： （1）补间动画只能定义两个关键帧在平移、旋转、缩放、透明度4个方面的变化，而属性动画则可以定义任何属性的变化。 （2）补间动画只能对UI组件指定动画，但属性动画几乎可以对任何对象指定动画（不管它是否显示在屏幕上）。 下面具体介绍属性动画以及它的使用。 属性动画API 属性动画涉及到的API如下。 Animator：提供创建属性动画的基类。一般是继承该类并重写它的指定方法。 ValueAnimator：属 性动画主要的时间引擎，负责计算各个帧的属性值。该类定义了属性动画的绝大部分核心功能，包括计算各帧的相关属性值，负责处理更新事件，按属性值的类型控制计算规则等。属性动画主要由两部分组成：①计算各帧的相关属性值；②为指定对象设置这些计算后的值。其中ValueAnimator只负责第1部分的内容。 ObjectAnimator：ValueAnimator的子类，实际开发中ObjectAnimator比ValueAnimator更常用。 AnimatorSet：Animator的子类，用于组合多个Animator，并指定它们的播放次序。 IntEvaluator：用于计算int类型属性值的计算器。 FloatEvaluator：用于计算float类型属性值的计算器。 ArgbEvaluator：用于计算以十六进制形式表示的颜色值的计算器。 TypeEvaluator：计算器接口，通过实现该接口自定义计算器。 在上面介绍的API中ValueAnimator与ObjectAnimator是最重要的，下面重点介绍这两个API的使用。 使用ValueAnimator创建动画 使用ValueAnimator创建动画有如下4个步骤： （1）调用ValueAnimator的ofInt()、ofFloat()或ofObject()静态方法创建ValueAnimator实例。 （2）调用ValueAnimator的setXxx()方法设置动画持续时间、插值方式、重复次数等。 （3）调用ValueAnimator的start()方法启动动画。 （4）为ValueAnimator注册AnimatorUpdateListener监听器，在该监听器中可以监听ValueAnimator计算出来的值的改变，并将这些值应用到指定对象上。 例如以下代码片段： 上面代码片段实现了在1s内，帧的属性值从0到1的变化。 如果使用自定义的计算器，如以下代码所示： 上面的代码片段仅仅是计算动画过程中变化的值，并没有把应用到对象上，所以不会有任何动画效果。如果大家想利用ValueAnimator创建出动画效果，还需要注册一个监听器AnimatorUpdateListener，该监听器负责更新对象的属性值。在实现这个监听器上，可以通过getAnimatedValue()方法获取当前帧的属性值，并将该计算出来的值应用到指定对象上。当该对象的属性持续改变时，动画效果就产生了。 使用ObjectAnimator创建动画 ObjectAnimator继承自ValueAnimator，因此可直接将ValueAnimator在动画中计算出来的值应用到指定对象的指定属性中，由于ValueAnimator已经注册了一个监听器来完成该操作，因此ObjectAnimator不需要注册AnimatorUpdateListener监听器。 使用ObjectAnimator的ofInt()、ofFloat()或ofObject()静态方法创建ObjectAnimator时，需要指定具体的对象，以及对象的属性名。 例如以下代码片段： 使用ObjectAnimator时需要注意以下几点： 要为该对象对应的属性提供setter方法，例如上面示例代码中需要为foo对象提供setAlpha(float value)方法。 调用ObjectAnimator的ofInt()、ofFloat()或ofObject()工厂方法时，如果value参数只提供一个值（正常是需要提供开始值和结束值），那么该值会被认为是结束值。此时该对象应该为该属性提供一个getter方法，该getter方法的返回值将被作为开始值。 在对View对象执行动画效果时，往往需要在onAnimationUpdate()事件监听方法中调用View.invalidate()方法来刷新屏幕显示，比如对Drawable对象的color属性执行动画。 使用属性动画 属性动画既可作用于UI组件，也可以作用于普通对象。定义属性动画有以下两种方式。 使用ValueAnimator或ObjectAnimator的静态工厂方法创建动画。 使用资源文件来定义动画。 使用属性动画的步骤如下。 （1）创建ValueAnimator或ObjectAnimator对象。 （2）根据需要为Animator对象设置属性。 （3）如果需要监听Animator的动画开始事件、动画结束事件、动画重复事件、动画值改变事件，并根据事件提供相应的处理代码，则应该为Animator对象设置事件监听器。 （4）如果有多个动画需要按次序或同时播放，则需要使用AnimatorSet。 （5）调用Animator对象的start()方法启动动画。 使用SurfaceView实现动画 前面介绍的很多示例中都使用到了自定义View类来绘图，但当View的绘图机制相比与SurfaceView还是存在缺陷，比如： （1）View缺乏双缓存机制。 （2）当View上的图片需要更新时必须重新绘制。 （3）新建的线程无法直接更新组件。 基于以上View的缺陷，Android一般推荐使用SurfaceView来绘制图片，尤其是在游戏开发中，SurfaceView的优势更明显。 SurfaceView一般与SurfaceHolder结合使用，SurfaceHolder用于向与之关联的SurfaceView上绘图，调用SurfaceView的getHolder()方法即可获取SurfaceView关联的SurfaceHolder。 SurfaceHolder提供了如下方法来获取Canvas对象。 Canvas lockCanvas()：锁定整个SurfaceView对象，获取该SurfaceView上的Canvas。 Canvas lockCanvas(Rect dirty)：锁定SurfaceView上Rect划分的区域，获取该SurfaceView上的Canvas。 unlockCanvasAndPost(canvas)：用于Canvas绘图完成之后释放绘图、提交所绘制的图形。 这两个方法的区别在于SurfaceView更新区域不同，第二个方法是对Rect划分的区域进行更新。 本章主要介绍了Android程序中的图形与图像处理，从绘图开始，接着讲解图形的特效处理，最后讲解Android中动画使用以及SurfaceView的绘图机制，学习完本章内容，大家需动手进行实践，为后面学习打好基础。 "},"page/1016.html":{"url":"page/1016.html","title":"文件","keywords":"","body":"文件 File存储 与Java中I/O流类似，Android同样支持用这种方式访问手机存储器上的文件。 打开应用中数据文件的IO流 Context中提供了如下两个方法来打开应用程序的数据文件夹中文件I/O流。 FileInputStream openFileInput(String name)：打开应用程序中数据文件夹下name文件对应的输入流。 FileOutputStream openFileOutput(String name, int mode)：打开应用程序中数据文件夹下name文件对应的输出流。 在openFileOutput(String name, int mode)方法中，mode参数是指打开文件的模式，支持的模式值如表所示。 Android中还提供了访问应用程序的数据文件夹方法，如表所示。 读写SD卡上的文件 上面介绍了如何打开应用程序中数据文件夹中的文件，考虑到手机内置的存储空间受限，应用程序中的大文件数据一般是在SD卡上完成读写操作的。在SD卡上读写文件的步骤如下： （1）调用Environment的getExternalStorageState()方法判断手机是否插入SD卡，并且该应用程序是否具有读写SD卡的权限。很多时候使用如下代码进行判断： Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); （2）调用Environment的getExternalStorageDirectory()方法获取SD卡的文件目录。 （3）使用FileInputStream、FileOutputStream、FileReader或FileWriter读写SD卡中的文件。 需要注意的是，读写SD卡上的数据时必须在程序的清单文件AndroidManifest.xml中添加读写SD卡的权限，具体如下所示： "},"page/1017.html":{"url":"page/1017.html","title":"数据库","keywords":"","body":"数据库 SQLlite数据库 Android系统集成了一个轻量级的数据库：SQLite，该数据库只是一个嵌入式的数据库引擎，专门适用于资源有限的设备上适量数据的存取。SQLite允许开发者使用SQL语句操作数据库中的数据，但是它并不需要安装，SQLite数据库只是一个文件。 SQLiteDatabase简介 SQLiteDatabase代表一个数据库（其实底层是一个数据库文件），当应用程序获取指定数据库的SQLiteDatabase对象后，就可以通过SQLiteDatabase对象管理和操作数据库。SQLiteDatabase提供了几个静态方法打开一个文件对应的数据库，如表所示。 获取SQLiteDatabase对象后就可调用SQLiteDatabase的如下方法来操作数据库，如表所示。 上面的insert、update、delete、query等方法完全可以通过执行SQL语句来完成，适用于对SQL语句不熟悉的开发者调用。 需要注意的是，上面的query方法都返回了一个Cursor对象，Cursor提供了如表所示的方法移动查询结果的记录指针。 一旦将记录指针移动到指定行后，就可通过调用Cursor的getXxx()方法获取该行的指定列的数据。 创建数据库和表 前面已经讲到，使用SQLiteDatabase的静态方法即可打开或创建数据库，例如如下代码： SQLiteDatabase.openOrCreateDataBase(\"/mnt/db/temp.db3\",null); 上面的代码就用于打开或创建一个SQLite数据库，如果/mnt/db/目录下的temp.db3文件 (该文件就是一个数据库）存在，那么程序就是打开该数据库；如果该文件不存在，则上面的代码将会在该目录下创建temp.db3文件（即对应于数据库)。 上面的代码中没有指定SQLiteDatabase.CursorFactory参数，该参数是一个用于返回 Cursor的工厂，如果指定该参数为null，则意味着使用默认的工厂。 上面的代码返回一个SQLiteDatabase对象，该对象的execSQL可执行任意的SQL语句。通过如下代码在程序中创建数据表： 在程序中执行上面的代码即可在数据库中创建一个数据表。 使用SQL语句操作SQLite数据库 SQLiteDatabase的execSQL方法可执行任意SQL语句，包括带占位符的SQL语句。但由于该方法没有返回值，因此一般用于执行DDL(data definition language)语句或DML(data manipulation language)语句；如果需要执行査询语句，则可调用SQLiteDatabase的rawQuery(String sql, String[] selectionArgs)方法。 使用特定方法操作SQLite数据库 考虑到可能有开发者对SQL语法不熟悉，SQLiteDatabase提供了insert、update、delete以及query语句来操作数据库。 1.使用insert方法插入记录 SQLiteDatabase中的insert方法包括3个参数，具体方法为insert(String table, String nullColumnHack, ContentValues values)，其中table为插入数据的表名，nullColumnHack是指强行插入null值的数据列的列名，当values参数为null时该参数有效，values代表一行记录的数据。 insert()方法中的第三个参数values代表插入一行记录的数据，该参数类型为ContentValues，ContentValues类似于Map，提供了put(String key, Xxx values)方法用于存入数据，getAsXxx(String key)方法用于取出数据。 具体示例代码片段如下： 不管values参数是否包含数据，执行insert()方法总会添加一条记录，如果values为空，则会添加一条除主键之外其他字段值都为null的记录。 另外还需要注意的是insert()方法返回类型为long。 使用update方法更新记录 SQLiteDatabase中的update()方法包含4个参数，具体方法为update(String table, ContentValues values, String whereClause, String[] whereArgs)，其中table为更新数据的表名，values为要更新的数据，whereClause 是指更新数据的条件，whereArgs为whereClause子句传入参数。update()方法返回int型数据，表示修改数据的条数。 修改person_inf表中所有主键大于15的人的姓名和地址，示例代码如下： 上面示例代码可更直观的看出，第四个参数whereArgs用于向第三个参数whereClause中传入参数。 使用delete方法删除记录 SQLiteDatabase中的delete()方法包含3个参数，具体方法为delete(String table, String whereClause, String[] whereArgs)，其中table是要删除数据的表名，whereClause是删除数据时的要满足的条件，whereArgs用于为whereClause传入参数。 删除person_inf表中所有姓名以“小”开头的记录，示例代码如下： 使用query方法查询记录 SQLiteDatabase中的query()方法包含9个参数，具体方法为query(boolean distinct, String table, String[] columns, String whereClause, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)，参数说明如下。 distinct：指定是否去除重复记录。 table：执行查询数据的表名。 columns：要查询出来的列名，相当于select语句select关键字后面的部分。 whereClause：查询条件子句，相当于select语句中where关键字后面的部分，在条件子句中允许使用占位符“？”。 selectionArgs：用于为whereClause子句中的占位符传入参数值，值在数组中的位置与占位符在语句中的位置必须一致；否则会出现异常。 groupBy：用于控制分组，相当于select语句group by关键字后面的部分。 having：用于对分组进行过滤，相当于select语句having关键字后面的部分。 orderBy：用于对记录进行排序，相当于select语句order by关键字后面的部分。 limit：用于进行分页。 该方法中参数较多，大家使用时如果不清楚各个参数的意义，可根据API查询。下面通过示例代码片段展示query()方法的使用，查询person_inf表中人名以“小”开头的记录。 query()方法返回的是Cursor类型对象。 事务 事务是并发控制的基本单元，SQLiteDatabase中包含如下两个方法来控制事务。 beginTransaction()：开始事务。 endTransaction()：结束事务。 SQLiteDatabase还提供了如下方法判断当前上下文是否处于事务环境中： inTransaction()：如果当前上下文处于事务环境中则返回true，否则返回false。 当程序执行endTransaction()方法后有两种选择，一种是提交事务，另一种是回滚事务。选择哪一种取决于SQLiteDatabase是否调用了setTransactionSuccessful()方法设置事务标志，如果设置了该方法则提交事务，否则回滚事务。 示例代码如下： SQLiteOpenHelper类 SQLiteOpenHelper是Android提供的一个管理数据库的工具类，可用于管理数据库的创建和版本更新。 前面介绍了使用SQLiteDatabase中的方法打开数据库，但是在实际开发中最常用的是SQLiteOpenHelper，通过继承SQLiteOpenHelper开发子类，并通过子类的getReadableDatabase()、getWritableDatabase()方法打开数据库。 SQLiteOpenHelper常用方法如表所示。 MySQLiteHelper工具类的作用主要是管理数据库的初始化，并允许应用程序通过该工具类获取SQLiteOpenHelper对象。 "},"page/1020.html":{"url":"page/1020.html","title":"其他","keywords":"","body":"其他 使用SharedPreferences 在一些应用程序中，有些数据需要在应用程序启动时就需要获取到，比如各种配置信息。通常这些数据都是通过SharedPreferences保存的。 SharedPreferences简介 SharedPreferences保存的数据主要是简单类型的key-value键值对。SharedPreferences是一个接口，所以程序无法直接创建SharedPreferences对象，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例。 SharedPreferences并没有提供写入数据的能力，而是通过其内部接口首先获取到Editor对象，通过Editor提供的方法向SharedPreferences写入数据。Editor提供的方法如表所示。 SharedPreferences接口主要负责读取应用程序中的Preference数据，提供了如表所示方法访问key-value键值对。 下面介绍SharedPreferences（以下简称SP）的简单使用。 SP的存储位置和格式 获取SP对象是通过Context提供的getSharedPreferences(String name, int mode)方法来获取，该方法中第一个参数设置保存的XML文件名，该文件用于SharedPreferences数据，第二个参数支持如表所示的几个值。 SharedPreferences数据是以key-value键值对的形式保存的。 SharedPreferences数据总是保存在/data/data//shared_prefs目录下，SharedPreferences数据总是以XML格式保存，根元素是元素，该元素中每个子元素代表一个key-value对，当value是整数类型时，使用子元素；当value是字符串类型时，使用子元素。 手势 Android开发中，几乎所有的事件都会和用户进行交互，而最多的交互形式就是手势。手势大概分为两个大类别，一类是左滑右滑，Google提供了手势检测并提供了相应的监听器。另一类就是画个圆圈、正方形等特殊手势，这种手势需要开发者自己添加手势识别，并提供了相关的API识别用户手势。 手势检测 Android为手势检测提供了一个GestureDetector类，GestureDetector实例代表了一个手势检测器，创建GestureDetector时需要传入一个GestureDetector.OnGestureListener实例，GestureDetector.OnGestureListener是一个监听器，负责对用户的手势行为提供响应。 GestureDetector.OnGestureListener中包含的事件处理方法如表所示。 使用Android的手势检测只需两个步骤。 （1）创建一个GestureDetector对象，创建时必须实现一个GestureDetector.OnGestureListener监听器实例。 （2）为应用程序的Activity的TouchEvent事件绑定监听器，在事件处理中指定把Activity上的TouchEvent事件交给GestureDetector处理。 增加手势 Android除了提供手势检测之外，还允许应用程序把用户手势（多个持续的触摸事件在屏幕上形成特定的形状）添加到指定的文件中，以备以后使用。如果程序需要，当用户下次再画出该手势时，系统将会识别该手势。 Android使用GestureLibrary来代表手势库，并提供了GestureLibraries工具类来创建手势库，GestureLibraries提供了如下4个静态方法从不同位置加载手势库。 static GestureLibrary fromFile(String path)：从path代表的文件中加载手势库。 static GestureLibrary fromFile(File path)：从path代表的文件中加载手势库。 static GestureLibrary fromPrivateFile(Context context, String name)：从指定应用程序的数据文件夹的name文件中加载手势库。 static GestureLibrary fromRawResource(Context context, int resourceId)：从resourceId所代表的资源中加载手势库。 当程序获取到GestureLibrary对象后，就可通过如表所示方法添加、识别手势。 Android 提供了一个手势编辑组件：GestureOverlayView，该组件就像一个“绘图组件”，只是用户绘制的是手势，不是图形。 为了监听GestureOverlayView ，Android提供了OnGestureListener、OnGesturePerformedListener、OnGesturingListener三个监听器，分别用于监听手势事件的开始、结束、完成、取消等事件，一般最常用多是OnGesturePerformedListener，用于提供完成时响应。 "},"page/1018.html":{"url":"page/1018.html","title":"网络应用","keywords":"","body":"网络应用 "},"page/1019.html":{"url":"page/1019.html","title":"多媒体应用","keywords":"","body":"多媒体应用 "}}