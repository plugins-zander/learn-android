# 事件处理

Android事件处理   

+ 基于监听的事件处理
+ 基于回调的事件处理
+ 响应系统设置的事件
+ Handler消息传递机制



## 基于监听的事件处理

### 事件监听的处理模型

+ 在事件监听的处理模型中，主要涉及三类对象：
  + Event Source（事件源）：一般指各个组件。
  + Event（事件）：一般是指用户操作，该事件封装了界面组件上发生的各种特定事件。
  + Event Listener（事件监听器）：负责监听事件源所发生的事件，并对该事件做出响应。
+ 实际上，事件响应的动作就是一组程序语句，通常以方法的形式组织起来。Android利用的是Java语言开发，其面向对象的本质没有改变，所以方法必须依附于类中才可以使用。而事件监听器的核心就是它所包含的方法，这些方法也被称为事件处理器(Event Handler)。
+ 事件监听的处理模型可以这样描述：当用户在程序界面操作时，会激发一个相应的事件，该事件就会触犯事件源上注册事件监听器，事件监听器再调用对应的事件处理器做出相应的反应。
+ Android的事件处理机制采用了一种委派式的事件处理方式：普通组件（事件源）将整个事件处理委派给特定的对象（事件监听器），当该组件发生指定的事件时，就通知所委托的事件监听器，由该事件监听器处理该事件。该流程如图所示。



![](https://img1.zlogs.net/20/20200507154154.png)



+ 这种委派式的处理方式很类似于人类社会的分工合作。举一个简单例子，当人们想邮寄一份快递（事件源）时，通常是将该快递交给快递点（事件监听器）来处理，再由快递点通知物流公司（事件处理器）运送快递，而快递点也会监听多个物流公司的快递，进而通知不同的物流公司。这种处理方式将事件源与事件监听器分离，从而提供更好的程序模型，有利于提高程序的可维护性。
+ 基于上面程序可以总结出基于监听的事件处理模型的编程步骤：
  + （1）获取要被监听的组件（事件源）。
  + （2）实现事件监听器类，该类是一个特殊的Java类，必须实现一个XxxListener接口。
  + （3）调用事件源的setXxxListener方法将事件监听器对象注册给事件源。

+ 当用户操作应用界面，触发事件源上指定的事件时，Android会触发事件监听器，然后由该事件监听器调用指定的方法（事件处理器）来处理事件。
  实际上，对于上述三个步骤，最关键的步骤是实现事件监听器类。实现事件监听器其实就是实现了特定接口的Java类实例，在程序中实现事件监听器，通常有如下几种形式。
  + 内部类形式：将事件监听器类定义成当前类的内部类。
  + 外部类形式：将事件监听器类定义成一个外部类。
    + Activity本身作为事件监听器类：让Activity本身实现监听器接口，并实现事件处理方法。
  + 匿名内部类形式：使用匿名内部类创建事件监听器对象。  



### 创建监听器的几种形式举例

+ 外部类形式创建监听器。

![](https://img1.zlogs.net/20/20200507154443.png)

+ 上面的事件监听器类实现了View.OnClickListener接口，创建该监听器时需要穿入一个Activity和一个TextView，来看具体Java代码：

![](https://img1.zlogs.net/20/20200507154654.png)

+ 上面程序第10行，用于给按钮的单击事件绑定监听器，当用户单击按钮时，就会触发监听器BtnClickListener，从而执行监听器里面的方法。

+ 外部类形式的监听器基本就是这样实现，专门定义一个外部类用于实现事件监听类接口作为事件监听器，之后在对应的组件中注册该监听器。
+ Activity本身作为事件监听器类。

![](https://img1.zlogs.net/20/20200507154804.png)

+ 上面程序中Activity直接实现了View.OnClickListener接口，从而可以直接在该Activity中定onClick(View v)。当为某个组件添加该事件监听器的时候，直接使用this关键字作为事件监听器即可。

+ 匿名内部类作为事件监听器。

![](https://img1.zlogs.net/20/20200507154944.png)

+ 可以看出匿名内部类的语法结构比较奇怪，除了这个缺点，匿名内部类相比于其他方式比较有优势，一般建议使用匿名内部类的方式创建监听器类。

### 在标签中绑定事件处理器

+ 上面的布局文件中第20行，Button设置了onClick属性，这行代码就已经为Button绑定了一个事件处理方法：btnClick，这也意味着开发者需要在对应的Activity中定义一个void btnClick(View v)的方法，该方法将会处理Button上的点击事件，来看Activity中的代码。

![](https://img1.zlogs.net/20/20200507155117.png)

+ 上面程序中的第11行就是属性onClick对应的方法，当用户点击该按钮时，btnClick方法将会被触发进而处理此点击事件。







## 基于回调的事件处理

### 回调机制

+ 前面提到监听机制是一种委派式的事件处理机制，事件源与事件监听器分离，用户触发事件源指定的事件之后，交给事件监听器处理相应的事件。而回调机制则完全相反，它的事件源与事件监听器是统一的，或者可以说，它没有事件监听器的概念。因为它可以通过回调自身特定的方法处理相应的事件。
+ 为了实现回调机制的事件处理，需要继承GUI组件类，并重写对应的事件处理方法，其实就是第2章中讲到的自定义UI组件的方法。Android为所有的GUI组件提供了一些事件处理的回调方法，以View类为例，该类包含如下表所示方法。

![](https://img1.zlogs.net/20/20200507155258.png)

+ 就代码实现的角度而言，基于回调的事件处理模型更加简单。

### 基于回调的事件传播

+ 开发者可控制基于回调的事件传播，几乎所有基于回调的事件处理方法都有一个boolean类型的返回值，该返回值决定了对应的处理方法能否完全处理该事件。当返回值为false时，表明该处理方法并未完全处理该事件，事件会继续向下传播；返回值为true时，表明该处理方法已完全处理该事件，该事件不会继续传播。因此对基于回调的事件处理方式而言，某组件上所发生的事件不仅会激发该组件上的回调方法，也会触发所在Activity的回调方法，只要该事件能传播到该Activity。



### 与监听机制对比

+ 对比这两种事件处理模型，可以看出基于监听的事件处理模型比较有优势：

  + 分工明确，事件源与事件监听器分来实现，可维护性较好。
  + 优先被触发。

+ 但在某些特定情况下，基于回调的事件处理机制能更好地提高程序的内聚性。

  

+ > 例如例2-1中， 就采用了回调的方式自定义了BallView类。通过为View提供事件处理的回调方法，可以很好的把事件处理方法封装在该View内部，从而提高程序的内聚性。
  > 基于回调的事件处理更适合解决如例2-1事件处理逻辑比较固定的View。









## 响应系统设置的事件

> 在实际开发中，经常会遇到横竖屏切换的问题，在Android应用中横竖屏切换并不仅仅是设备屏幕的横竖屏切换，它还涉及Activity生命周期的销毁与重建的问题。所以当遇到类似横竖屏切换这样的系统设置问题时，应用程序就需要根据系统的设置做出相应的改变，这就是本节要讲述的内容。



### Configuration类简介

+ Configuration类专门用来描述Android手机的设备信息，这些配置信息既包括用户特定的配置项，也包括系统的动态设备配置。
+ 获取Configuration对象的方式很简单，只需要一行代码就可以实现：

```java
Configuration cfg = getResources().getCongigration();
```

+ 获取了该对象之后，就可以通过该对象提供的如表所示的属性来获取系统的配置信息。

![](https://img1.zlogs.net/20/20200507155823.png)







### onConfigurationChanged方法

+ 在Android应用中，经常会看到应用程序为适应手机屏幕的横竖屏切换，也切换了横竖屏显示方式。实现此功能需要对屏幕的横竖屏变化进行监听，可以通过重写Activity的onConfigurationChanged(Configuration newConfig)方法实现监听。该方法是一个基于回调的事件处理方法：当系统设置发生变化时，该方法会被自动触发。













## Handler消息传递机制

+ 开发一款APP肯定都会涉及到更新UI的问题，而Android中规定：只允许UI线程修改Activity中的UI组件。
+ UI线程就是主线程，是随着应用程序启动而自动启动的一条线程，它主要负责处理与UI相关的问题，例如用户的单击操作、触摸屏操作以及屏幕绘图等，并把相关的事件分发到对应的组件进行处理。
+ 既然Android官方规定只能在UI线程中更新UI组件，那是不是新启动的线程就无法动态改变UI组件的属性值了呢？答案当然是否定的。本节中的Handler消息传递机制就可以轻松解决这个问题。

### Handler类简介

+ Handler类可以在新启动的线程中向主线程发送消息，主线程中获取到消息并处理相应操作，从而达到更新UI的效果。
+ Handler采用回调的方式处理新线程发送来的消息。当新启动的线程发送消息后，消息被发送到与之相关联的MessageQueue中，最后Handler不断从MessageQueue中获取并处理消息。Handler类包含如下方法用于发送、处理消息，如表所示。

![](https://img1.zlogs.net/20/20200507160102.png)

+ 借助于上面这些方法，就可以利用Handler实现消息的传递。
+ Handler通过重写handleMessage(Message msg)方法来接收新线程发送来的消息（被自动回调），而handleMessage(Message msg)方法存在于主线程中，因此可动态修改ImageView属性值。这样就实现了由新线程修改UI组件的效果。











### Handler、Loop及MessageQueue三者的关系

+ 前面提到新线程将消息发送至MessageQueue，然后Handler不断从MessageQueue中获取并处理消息。Handler从MessageQueue中读取消息就要用到Looper，Looper的loop方法负责读取MessageQueue中的消息，读取消息之后把消息发送给Handler来处理。

![](https://img1.zlogs.net/20/20200507160416.png)



+ 上图很好地展示了这三者之间的关系，可以看出，如果希望Handler正常工作，必须在当前线程中有一个Looper对象。而Looper的创建分为两种情况：
  + （1）在主线程即UI线程中，系统已默认初始化了一个Looper对象，因此程序可直接创建Handler即可。
  + （2）开发者新建的子线程中，必须自己创建一个Looper对象并启动它，才可使用Handler。创建Looper对象调用它的prepare()方法即可。
+ 下面来分别归纳一下这三者的作用，如表所示。

![](https://img1.zlogs.net/20/20200507160521.png)

+ 在新建的线程中使用Handler的步骤如下：
  + （1）调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，Looper的构造方法会自动创建与之匹配的MessageQueue。
  + （2）Looper创建完成之后，开始创建Handler实例，并重写handleMessage()方法，该方法负责处理来自于其他线程的消息。
  + （3）调用Looper的loop()方法启动Looper。





















